<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud学习--《重新定义SpringCloud实战》读书笔记]]></title>
    <url>%2F2018%2F12%2F18%2FSpringCloud%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SpringCloud提供了快速构建分布式中常见模式的工具，包括配置管理、服务发现、断路器、智能路由、微代理、控制总线等。SpringCloud中间件是基于SpringBoot的实现，提供了对微服务完整的一套解决方案。 应用架构的发展历程：单体应用架构 –&gt; 分布式架构 –&gt;面向服务的SOA架构 –&gt; 微服务架构SOA架构个人理解是多个应用之间通过企业数据总线ESB通信的架构，其应用程序通过网络协议提供服务，消费服务，不同业务提供不同的服务。(阿里的服务治理框架Dubbo)微服务架构：一个大型的应用拆分为多个相互独立的微服务，每个服务之间松耦合，通过REST API或者HTTP进行通信。 SpringCloud包包含以下组件：服务治理组件 Eureka / Consul + 客户端负载均衡组件 Ribbon + 声明式服务调用组件 Feign + API网关治理组件 Zuul / GateWay(高并发) + 熔断机制 HyStrix + 分布式配置中心组件 Spring Cloud Config / 携程 Apollo + 消息总线组件 Bus + 消息驱动组件 Stream + 分布式服务跟踪组件 Sleuth + 全链路监控 SkyWalking. Tips: 代码基于Spring Cloud Finchley 版本 服务治理：Spring Cloud Eureka负责微服务架构中的服务治理功能，即各个微服务实例的自动化注册与发现。SpringCloud Eureka 是由 Netflix Eureka实现的，即包含了服务端组件也包含了客户端组件。Eureka服务端也被称为服务注册中心，各个微服务启动时会向Eureka Server 注册自己的信息。代码如下：在https://start.spring.io/ 中新建一个Eureka Server的Demo，或者直接在Maven项目中的pom.xml文件中添加如下Dependence:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; EurekaServerApplication.java1234567891011121314151617package com.leezy.eureka_server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication//该注解启动一个服务注册中心提供给其他应用会话@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; System.out.println("Hello Eureka Server!"); SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; Eureka Server 中的 application.yml 和 application-standalone.yml12345678910111213141516# application.ymlspring: profiles: active: standalone jackson: serialization: FAIL_ON_EMPTY_BEANS: falseeureka: server: use-read-only-response-cache: false response-cache-auto-expiration-in-seconds: 10management: endpoints: web: exposure: include: '*' 123456789101112131415# application-standalone.ymlserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false #是否将自己注册到Eureka Server, 默认为True fetchRegistry: false #是否需要从Eureka Server获取注册信息, 默认为Ture serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 查询服务和注册服务的地址，多个用","隔开 server: waitTimeInMsWhenSyncEmpty: 0 enableSelfPreservation: false 打开 http://localhost:8761/ 看到Eureka的控制面板。Eureka服务注册端， Eureka Client将微服务注册到Eureka Server上。EurekaClientApplication.java1234567891011121314151617package com.leezy.eureka_client;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication// 该注解适配性比较好，可以用于多种服务发现组件(Zookeeper、Consul)@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; System.out.println("Hello Eureka Client!"); SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; Maven依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; Eureka Client的配置文件： application.yml 和 application-demo.yml1234#application.ymlspring: profiles: active: demo 1234567891011121314#application-demo.ymlserver: port: 8081Spring: application: name: demo-leezy #声明服务提供者的应用名称eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #设置与Eureka Server交互的地址 instance: prefer-ip-address: true 刷新Eureka控制台就可以看到注册到Server上的服务了。 Eureka的设计理念： 服务实例如何注册到服务中心：（1）调用Eureka Server的REST API 的 register方法（2）Java语言使用者可以调用NetFlix的Eureka Client封装的API（3）Spring Cloud使用者在pom.xml文件中引用 spring-cloud-starter-netflix-eureka-client，基于Spring Boot的自动配置即可。 服务实例从服务中心剔除（1）服务实例正常关闭时，通过钩子方法或者生命周期回调方法调用Eureka Server 的REST API的de-register方法。（2）Eureka要求Client定时续约(30s)，如果90s没有续约操作则Eureka Server主动剔除该操作。 服务实例信息的一致性问题服务注册与发现中心应该也是一个集群，如何保证一致性（1）AP优于CP (Zookeeper-CP, Eureka-AP)（2）Peer to Peer架构(1. 主从复制 2. 对等复制)（3）Zone及Region设计（4）SELF PRESERVATION设计 WebService客户端 FeignFeign是一个声明式的Web Service客户端，用于服务与服务之间的调用，支持SpringMVC注解，整合了Ribbon以及Hystrix。对应的POM依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 应用入口程序SpringCloudFeignApplication.java123456789101112131415package com.leezy.hello_feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class HelloFeignApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(HelloFeignApplication.class, args); &#125;&#125; 接口类：HelloFeignService.java，作用是应用指定的URL最终转化为Github API允许的URL。eg：https://api.github.com/search/repositories?q=spring-cloud(Github RestAPI的文档：https://developer.github.com/v3/search/)1234567891011121314package com.leezy.hello_feign.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import com.leezy.hello_feign.config.HelloFeignServiceConfig;@FeignClient(name = "github-client", url = "https://api.github.com", configuration = HelloFeignServiceConfig.class)public interface HelloFeignService &#123; @RequestMapping(value = "/search/repositories", method = RequestMethod.GET) String searchRepo(@RequestParam(name = "q") String quertStr);&#125; 控制类：HelloFeignController.java，作用：调用服务提供者的接口123456789101112131415161718192021package com.leezy.hello_feign.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.leezy.hello_feign.service.HelloFeignService;@RestControllerpublic class HelloFeignController &#123; @Autowired private HelloFeignService helloFeignService; @GetMapping(value = "/search/github") public String searchGithubRepoByStr(@RequestParam("str") String queryStr) &#123; return helloFeignService.searchRepo(queryStr); &#125;&#125; 配置类：HelloFeignServiceConfig.java，@Bean注解配置日志的bean123456789101112131415package com.leezy.hello_feign.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import feign.Logger;@Configurationpublic class HelloFeignServiceConfig &#123; @Bean Logger.Level feignLoggerLevel() &#123; //level有四个级别 return Logger.Level.FULL; &#125;&#125; 配置文件: application.yml123456789server: port: 8010spring: application: name: Hello Feignlogging: level: com.leezy.hello_feign.service.HelloFeignService: DEBUG #在这里配置日志的输出级别 启动应用后，访问网址：http://localhost:8010/search/github?str=spring-cloudFeign支持的属性文件配置方式有两种：application.yml(application.properties) 以及 Java方式的配置类，但是配置文件的优先级会高于Java类的优先级。Feign默认的是JDK原生的URL Connection，并没有使用连接池，可以用Http Client和 okHttp进行替换对项目进行调优。 Feign 的 POST 和 GET 的多参数传递Feign拦截器，将Json转化为Map。实现Feign的RequestInterceptor中的apply方法来进行统一拦截转换处理Feign中的GET方法多参数传递问题。集成Swapper，编写服务消费者用于调用Feign进行Get或Post多参数传递。 负载均衡组件 RibbonFeign中集成了Ribbon，但是Ribbon可以单独使用，它是一种进程内负载均衡器（客户端负载均衡），它赋予了应用支配Http和Tcp的能力。负载均衡策略：最常用的是RoundRobinRule 轮询策略代码样例：pom.xml12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动类：RibbonLoadbalancerApplication.java注入一个RestTemplate的Bean，并且使用@LoadBalances注解才能使其具备负载均衡的能力。1234567891011121314151617181920212223package cn.springcloud.book;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplication@EnableDiscoveryClientpublic class RibbonLoadbalancerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonLoadbalancerApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; TestController.javaRibbon客户端需要创建一个API来调用Eureka源服务自定义的API12345678910111213141516171819import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/add") public String add(Integer a, Integer b) &#123; String result = restTemplate .getForObject("http://CLIENT-A/add?a=" + a + "&amp;b=" + b, String.class); System.out.println(result); return result; &#125;&#125; 通过查找继承关系，发现接口ILoadBalancer的实现抽象类AbstractLoadBalancer的实现类BaseLoadBalancer中的chooseServer方法是真正实现负载均衡的地方。123456789101112131415161718192021/* * Get the alive server dedicated to key * * @return the dedicated server */public Server chooseServer(Object key) &#123; if (counter == null) &#123; counter = createCounter(); &#125; counter.increment(); if (rule == null) &#123; return null; &#125; else &#123; try &#123; return rule.choose(key); &#125; catch (Exception e) &#123; logger.warn("LoadBalancer [&#123;&#125;]: Error choosing server for key &#123;&#125;", name, key, e); return null; &#125; &#125;&#125; 熔断机制 Spring Cloud HystrixHystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.Hystrix的设计目标是： 通过客户端对延迟和故障进行保护和控制 在一个复杂的分布式系统中停止级联故障 快速失败和迅速恢复 在合理的情况下回退和优雅地降级 开启实时监控、告警和操作控制pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.leezy&lt;/groupId&gt; &lt;artifactId&gt;hystrix&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hystrix&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; ClientApplication.java123456789101112131415package com.leezy.hystrix;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@SpringBootApplication@EnableHystrix@EnableDiscoveryClientpublic class ClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApplication.class, args); &#125;&#125; TestController.java12345678910111213141516171819package com.leezy.hystrix.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.leezy.hystrix.service.IUserService;@RestControllerpublic class TestController &#123; @Autowired private IUserService userService; @GetMapping("/getUser") public String getUser(@RequestParam String username) throws Exception&#123; return userService.getUser(username); &#125;&#125; IUserService.java12345package com.leezy.hystrix.service;public interface IUserService &#123; public String getUser(String username) throws Exception;&#125; UserService.java12345678910111213141516171819202122232425package com.leezy.hystrix.service.impl;import org.springframework.stereotype.Component;import com.leezy.hystrix.service.IUserService;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;@Componentpublic class UserService implements IUserService&#123; // 降级处理 @Override @HystrixCommand(fallbackMethod="defaultUser") public String getUser(String username) throws Exception &#123; if (username.equals("spring")) &#123; return "This is real user."; &#125; else &#123; throw new Exception(); &#125; &#125; public String defaultUser(String username) &#123; return "The User does not exist in the system...Test!"; &#125;&#125; bootstrap.yml1234567891011server: port: 8888spring: application: name: hystrix-client-serviceeureka: client: serviceUrl: defaultZone: http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8761&#125;/eureka/ instance: prefer-ip-address: true 打开浏览器访问：http://localhost:8888/getUser?username=spring 和 http://localhost:8888/getUser?username=testERROR Hystrix DashboardHystrix Dashboard仪表盘是根据系统一段时间内发生的请求情况来展示的可视化面板。Hystrix的指标需要端口进行支撑，所以需要增加actuator依赖。pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; HystrixDashboardApplication.java12345678@SpringBootApplication@EnableDiscoveryClient@EnableHystrixDashboardpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; 上面是单个实例的Hystrix Dashboard,整个系统和集群的情况下并不是特别有用。Turbine就是聚合所有相关Hystrix.stream 流的方案。 网关治理组件 ZuulZuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. Zuul是对内部的微服务提供可配置的，对外URL到服务的映射关系，基于JVM的后端路由器。pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 启动类ZuulServerApplication.java12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class ZuulServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulServerApplication.class, args); &#125;&#125; bootstrap.yml12345678910111213141516spring: application: name: zuul-serverserver: port: 5555eureka: client: serviceUrl: defaultZone: http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8888&#125;/eureka/ instance: prefer-ip-address: truezuul: routes: client-a: path: /client/** serviceId: client-a 最后五行的代码表示，Zuul组件的端口为portA，则将/client开头的URL映射搭配client-a这个服务中去，即实际访问portB。/* 匹配任意数量的路径和字符/ 匹配任意数量的字符/? 匹配单个字符 Spring Cloud Zuul Filter链(1) Filter的类型(2) Filter的执行顺序(3) Filter的执行条件(4) Filter的执行效果Zuul有四种不同生命周期的Filter,分别是：pre Filter 按照规则路由到下级服务之前执行。比如鉴权、限流等route Filter 路由动作的执行者（Apache HttpClient或Netflix Ribbon构建和发送原始Http请求的地方）post Fliter 在源服务返回结果或者异常信息发生后执行的，对返回信息做一些处理error Filter 在整个生命周期内如果发生异常，则会进入error Filter Spring Cloud Zuul 权限集成OAuth2.0 + JWT(JSON Web Token) 动态路由 Dynamic Routing有两种解决方案：（1） Spring Cloud Config + Bus、动态刷新配置文件。（2） 重写Zuul的配置读取方式 P.S. bootstrap.yml和appllication.yml的区别bootstrap.yml加载（父SpringApplicationContext）顺序在application.yml之前，用于应用程序上下文的引导阶段。用于指定spring.application.name和spring.cloud.config.server.git.uri以及一些加密和解密信息。eg：Spring Cloud Config 配置中心再使用时，通常将访问远程文件配置信息写在bootstrap.yml文件中。]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习]]></title>
    <url>%2F2018%2F12%2F11%2FSpringBoot%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. 1. 常见注解@RequestMapping (@GetMapping &amp; @PostMapping)The @RequestMapping annotation provides “routing” information. It tells Spring that any HTTP request with the / path should be mapped to the home method.@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。 @RestControllerThe @RestController annotation tells Spring to render the resulting string directly back to the caller. @EnableAutoConfigurationSince spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. @SpringBootApplicationThe @SpringBootApplication annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items. same as @Configuration，@EnableAutoConfiguration, @ComponentScan.12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @ConfigurationDeclare the configuration Classes. @EnableAutoConfigurationIf you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them.12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 单元测试常用注解 @RunWith(SpringJUnit4ClassRunner.class)引入Spring对JUnit4的支持。 @SpringApplicationConfiguration(classes = HelloApplication.class)指定SpringBoot的启动类 @WebAppConfiguration开启Web应用配置，用于模拟ServletContext @Before &amp; @Test &amp; @After@Before：JUnit中定义在测试用例@Test内容执行前预加载的内容，同理判断。 2. Starter POMs1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 命名规则都是spring-boot-starter-，代表一个特别的应用功能模块。 spring-boot-starter-web全栈Web开发模块，包含嵌入式的Tomcat、SpringMVC spring-boot-starter-test包含Junit、Hamcrest、Mockito spring-boot-starter-actuator为SpringBoot构建的应用提供一系列用于监控的端点。访问：http://127.0.0.1:8080/actuator可以看到输出了如下JSON文件：123456789101112131415161718192021222324&#123; "_links": &#123; "self": &#123; "href": "http://127.0.0.1:8080/actuator", "templated": false &#125;, "health": &#123; "href": "http://127.0.0.1:8080/actuator/health", "templated": false &#125;, "health-component": &#123; "href": "http://127.0.0.1:8080/actuator/health/&#123;component&#125;", "templated": true &#125;, "health-component-instance": &#123; "href": "http://127.0.0.1:8080/actuator/health/&#123;component&#125;/&#123;instance&#125;", "templated": true &#125;, "info": &#123; "href": "http://127.0.0.1:8080/actuator/info", "templated": false &#125; &#125;&#125; spring-boot-devtools(1) Property Defaults(2) Automatic Restart(3) LiveReload(4) Global Settings(5) Remote Applications 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 配置文件SpringBoot的默认配置文件位置是src/main/resources/application.properties.123&lt;!-- application.properties --&gt;book.name=JAVA编程思想book.author=Bruce Eckel 应用中可以使用 @Vlaue注解来加载这些自定义的参数1234567@Componentpublic class Book &#123; @Value("$&#123;book.name&#125;") private String name; @value("$&#123;book.author&#125;") private String author;&#125; Java代码中引用有以下两种方式： PlaceHolder方式 ${…} SpEL表达式 #{…} 通过application-{profile}多环境配置文件：application-dev.properties:开发环境application-test.properties:测试环境application-prod.properties:生产环境在application.properties中的spring.profiles.active属性来设置。12// 调用测试环境spring.profiles.active = test; 在采用java -jar xxx.jar 形式运行项目时，”–”就是对application.properties中的属性值进行赋值的标识。配置文件的优先级顺序如下：命令行输入 &gt; 包外 &gt; 包内所以可以在利用这一点来对配置进行快速准确的更改。 spring.factories文件Spring Factories实现原理(package org.springframework.core.io.support;) spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法： loadFactories: 根据接口类获取其实现类的实例，这个方法返回的是对象列表。loadFactoryNames: 根据接口获取其接口类的名称，这个方法返回的是类名的列表。]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService学习]]></title>
    <url>%2F2018%2F11%2F26%2FWebService%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[WebService的两种实现方式，Soap WebService、Restful WebService。 RPC refers to Remote Procedure Call.Use of RPC is recommended when there is heavy use of the client/server model.RPC allows for the processing of multiple threads that share a given address.RPC employed on a platform that uses EJB.Web Service used in non-Java platforms when an app wants access.Web Service also is used for synchronization of asynchronous communication.[1] WebService是一种技术，有两种实现方式：JAX-WS(Java API for XML-Based Service面向消息)、JAX-RS(Java API for Restful WebService面向资源)ps. RESTful 请求常用的方法有以下四种： GET: 用于查询对象 POST: 用于创建对象 PUT: 用于修改对象 DELETE: 用于删除对象 1. CXF 基于 SOAP 的 WebService12345678&lt;!-- IHelloWorld.java --&gt;package top.leezy.www;import javax.jws.WebService;@WebServicepublic interface IHelloWorld &#123; String sayHello(String name);&#125; 12345678&lt;!-- HelloWorldImpl.java --&gt;package top.leezy.www;public class HelloWorldImpl implements IHelloWorld &#123; public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; 1234567891011121314151617&lt;!-- applicationContext.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:cxf="http://cxf.apache.org/core" xmlns:wsa="http://cxf.apache.org/ws/addressing" xsi:schemaLocation="http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.1.xsd http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;jaxws:endpoint id="HelloWorld" implementor="top.leezy.www.HelloWorldImpl" address="/sayHello" /&gt; &lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- web.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;CXFwebservice&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:top/**/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;CxfServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CxfServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 打开浏览器输入：http://127.0.0.1:8081/SoapWebService/webservice 2. CXF 基于 RestFul 的 WebService12345678910111213141516&lt;!-- Config.java --&gt;package top.leezy.www;import java.util.LinkedList;import java.util.List;public class Config &#123; public static List&lt;User&gt; users; static &#123; users = new LinkedList&lt;User&gt;(); User user = new User(); user.setId("123456"); user.setName("SAKURA"); users.add(user); &#125;&#125; 12345678910111213141516171819202122232425262728&lt;!-- User.java --&gt;package top.leezy.www;import javax.xml.bind.annotation.XmlRootElement;@XmlRootElement(name = "User")public class User &#123; private String name; private String id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- UserService.java --&gt;package top.leezy.www;import javax.ws.rs.Consumes;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.PUT;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.PathParam;import javax.ws.rs.QueryParam;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.Response.Status;@Path("/UserService")// 可以注释在方法上或者类上（以最小单位为准）, 指定返回给客户端的类型@Produces(&#123;"application/json", "application/xml"&#125;)public class UserService &#123; @GET @Path("/getUser/&#123;id&#125;") @Produces(MediaType.APPLICATION_XML) public User getUser(@PathParam("id") String id) &#123; if (id != null &amp;&amp; id.length() &gt; 0) &#123; for (User user : Config.users) &#123; if(id.equals(user.getId())) return user; &#125; User add_user = new User(); add_user.setId(id); return add_user; &#125; else &#123; return new User(); &#125; &#125; @POST @Path("/regUser") // 一般用于 @PUT、@POST, 用于接受客户端发送过来的MIME类型 @Consumes(&#123;"application/json", "application/xml"&#125;) public Response regUser(User user) &#123; if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125; else &#123; Config.users.add(user); return Response.ok("id = " + user.getId() + ", name = " + user.getName()).build(); &#125; &#125; @DELETE @Path("/delUser") @Consumes(&#123;"application/json", "application/xml"&#125;) public Response delPerson(@QueryParam("id") String id) &#123; User user = new User(); user.setId(id); if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125; else &#123; Config.users.remove(user); return Response.ok(user).build(); &#125; &#125; @PUT @Path("/updateUser") @Consumes(&#123;"application/json", "application/xml"&#125;) public Response updateUser(User user) &#123; if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125;else &#123; for (User old_user : Config.users) &#123; if (old_user.equals(user)) &#123; old_user.setName(user.getName()); &#125; &#125; return Response.ok(user).build(); &#125; &#125;&#125; 123456789101112131415161718192021&lt;!-- beans.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jaxrs="http://cxf.apache.org/jaxrs" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd"&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;bean id="userService" class="top.leezy.www.UserService" /&gt; &lt;jaxrs:server id="rs_server" address="/restfulService"&gt; &lt;jaxrs:serviceBeans&gt; &lt;ref bean="userService" /&gt; &lt;/jaxrs:serviceBeans&gt; &lt;/jaxrs:server&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031&lt;!-- web.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CxfRestWebservice&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:top/**/beans.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 打开浏览器输入：http://127.0.0.1:8081/RestFulWebService/webservice/使用POSTMan进行测试：RestFul WebService 的JAR包较 Soap WebService 要区别以下几个：-javax.ws.rs-api-2.1.1.jar-cxf-rt-frontend-jaxrs-3.2.7.jar 参考文献：[1]http://www.differencebetween.net/technology/protocols-formats/difference-between-rpc-and-web-service/#ixzz5YLemRQhd[2]https://www.cnblogs.com/zhuyiqizhi/p/6213502.html]]></content>
      <tags>
        <tag>JavaWEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装Tomcat]]></title>
    <url>%2F2018%2F11%2F20%2FCentOS%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[系统：CentOS Linux release 7.5.1804Tomcat版本： apache-tomcat-7.0.92.tar.gz 1. 下载Tomcat下载链接：https://www-us.apache.org/dist/tomcat/tomcat-7/v7.0.92/bin/apache-tomcat-7.0.92.tar.gz 2. 解压缩文件1tar -zxvf apache-tomcat-7.0.92.tar.gz 3. 打开8080端口并重启防火墙12firewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --reload 4. 配置tomcat-users.xml12345&lt;!-- 在最后添加用户角色用户名密码 参数意义可以在自带的文档上查看--&gt;&lt;role rolename="admin-gui"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;role rolename="manager-jmx"/&gt;&lt;user username="admin" password="admin" roles="admin-gui,manager-gui,manager-jmx" /&gt; 5. 访问Tomcat Manager访问地址： http://192.168.56.101:8080/ 并登陆 admin admin]]></content>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB安装]]></title>
    <url>%2F2018%2F11%2F20%2FMongoDB%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装解压缩版本的MongoDB(mongodb-win32-x86_64-2008plus-ssl-4.0.4)的简单命令。 1. 配置环境变量12# 加入环境变量C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\bin 2. 创建 data 文件夹 及 log 文件夹创建 mongodb-data 和 mongodb-log 文件夹 3. 用管理员权限执行安装命令12cd C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\binmongod --dbpath "C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\mongodb-data" --logpath "C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\mongodb-log\MongoDB.log" --install --serviceName "mongo" --logappend --directoryperdb 4. 测试安装结果访问 http://127.0.0.1:27017/]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实验记录]]></title>
    <url>%2F2018%2F03%2F06%2FTensorFlow%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[环境说明：系统：Ubuntu Server 16.04.1 LTS 64位Python版本：Python 3.5.2TensorFlow版本：1.4 用户切换（最好启用root否则会有Bug）1234# 输入Linux root用户密码sudo passwd root# 默认用户切换到root用户su root 安装python环境12345# 不用默认的2.7 安装python3.5sudo apt-get install python3.5# 系统环境切换成python3.5sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 安装TensorFlow12345678# 采用pip安装，首先安装# 查看系统内置的pip版本pip3 -V# 更新并安装sudo apt-get install python3-pip python3-devsudo pip install --upgrade pip# 安装CPU版本的TensorFlowpip3 install tensorflow 注意要保证pip是最新版本否则会出现以下错误： 测试TensorFlow123456python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello)) 查看TensorFlow版本 备用知识点(Note)123451. vim -r filename 恢复未正常保存生成的.swap文件2. (Note)convolutional neural network 卷积神经网络rectified linear unit 线性修正单元 ReLUinput layer --&gt; hidden layer(more than one) --&gt; output layer 环境准备12345678910111213pip3 install -U scikit-learnpip3 install scipy# 下载 MNIST 数据集（http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_download.html）wget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/t10k-images-idx3-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/t10k-labels-idx1-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/train-images-idx3-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/train-labels-idx1-ubyte.gzpip3 install \ -i https://pypi.tuna.tsinghua.edu.cn/simple/ \ https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/tensorflow-1.7.0-cp35-cp35m-linux_x86_64.whl Windows环境下.ipynb文件相关（python笔记）1234567# 安装python环境不必多说pip install ipythonpip install &quot;ipython[notebook]&quot;# cd 到有.ipynb文件的目录下执行下列命令就会自动打开浏览器点击文件即可打开文件ipython notebook]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++标准模板库STL学习笔记]]></title>
    <url>%2F2018%2F02%2F27%2FC%2B%2B%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面试笔试算法必备知识点！文章内容总结自《算法笔记》，时刻巩固以免忘记(lll￢ω￢) 1.vectory用法：Vectory：变长数组 定义方法： 1234567891011vectory&lt;typename&gt; name;// eg:vectory&lt;int&gt; nums;// 如果typename类型也是一个STL容器，定义方式如下：vectory&lt;vectory&lt;int&gt; &gt; name; // &gt;&gt;之间有空格避免歧义 --》两维都可变的二维数组// vectory数组的定义方式如下：vectory&lt;typename&gt; Arrayname[arraySize] // 一维可变的二维数组// eg:vectory&lt;int&gt; nums[10] 访问方法： 123456789// 通过下标访问：nums[0], nums[1];// 通过迭代器访问：vectory&lt;typename&gt;::iterator it;//eg:vectory&lt;int&gt;::iterator it; // 得到迭代器it，通过*it进行访问vectory// nums[i] 等价于 *(it + i) 常用函数： 1234567891. push_back(x) 在vectory末尾添加一个元素x O(1) nums.push_back(i);2. pop_back() 在vectory末尾删除一个元素 O(1) nums.pop_back();3. size() 求得vectory元素个数 O(1) nums.size()4. begin() 求得vectory数组nums首地址与it指向地址一样 O(1) nums.beagin()5. end() 求得vectory数组nums尾元素的下一个地址 O(1) nums.end()6. clear() 清空vectory所有元素 O(n) nums.clear()7. insert(it, x) 向vectory任意迭代器it处插入一个元素x O(N) nums.insert(nums.begin() + 2， 3)8. erase(it) 删除迭代器it处元素 O(n) nums.erase(nums.begin() + 2)9. erase(first, last) 删除[first, last)内的所有元素 O(n) nums.erase(num.begin() + 1, num.end())删除除第一个元素外的其他元素]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架总结]]></title>
    <url>%2F2017%2F08%2F09%2FSSM%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SSM框架的一些基本知识总结。 1.SSM定义SSM = Spring + SpringMVC + MyBatisSpring:Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC命名及分层：edu.xju.common.util 公共部分edu.xju.controller 控制层edu.xju.dao 数据层edu.xju.entity 实体层edu.xju.service 服务层 MyBatis:比Hibernate要灵活多用于需求不断变更的项目。 2.Web项目执行顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- web.xml 程序执行入口 --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- 如果使用如下配置，Spring Web MVC框架将加载“classpath:spring-mvc.xml”来进行初始化上下文而不是“/WEB-INF/[servlet名字]-servlet.xml”。 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）。 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- load-on-startup：表示启动容器时初始化该Servlet； --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;!-- 从main.jsp开始 --&gt; &lt;welcome-file&gt;main.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; DispatcherServlet拦截所有请求，在这里是拦截.do和.json结尾的请求。该DispatcherServlet默认使用WebApplicationContext作为上下文，Spring默认配置文件为“/WEB-INF/[servlet名字]-servlet.xml”。ContextLoaderListener初始化的上下文和DispatcherServlet初始化的上下文关系ContextLoaderListener初始化的上下文加载的Bean是对整个应用程序共享的；DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean；即只加载Web相关的组件。DispatcherServlet的继承关系 DispatcherServlet initialization parameters HttpServletBean继承HttpServlet，因此在Web容器启动时将调用它的init方法，该初始化方法的主要作用将Servlet初始化参数（init-param）设置到该组件上（如contextAttribute、contextClass、namespace、contextConfigLocation），通过BeanWrapper简化设值过程，方便后续使用；提供给子类初始化扩展点，initServletBean()，该方法由FrameworkServlet覆盖。 FrameworkServlet继承HttpServletBean，通过initServletBean()进行Web上下文初始化，该方法主要覆盖一下两件事情： 初始化web上下文； 提供给子类初始化扩展点； DispatcherServlet继承FrameworkServlet，并实现了onRefresh()方法提供一些前端控制器相关的配置； 12345678910111213141516171819202122232425262728&lt;!-- spring-mvc.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 扫描这个控制包内部的Controller --&gt; &lt;context:component-scan base-package="edu.xju.controller"/&gt; &lt;mvc:annotation-driven /&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// spring-mybatis.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;context:component-scan base-package="edu"/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb?charsetEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--sessionFactory代理--&gt; &lt;bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--注解扫描--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="edu.xju.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sessionFactory"/&gt; &lt;/bean&gt; &lt;!--spring 事务管理--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--定义事务声明 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceAop" expression="execution(* edu.xju.service.*Service.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceAop" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011121314151617181920212223// main.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;基本的 ssm 框架&lt;/title&gt;&lt;style type="text/css"&gt; a&#123; font-size: 20px; display: block; margin-top: 30px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/addUser.do"&gt;添加用户&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/list.do"&gt;查找所有用户&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/getUserA.json?id=1"&gt;获取某个用户JSON格式1&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/getUserB.json?id=2"&gt;获取某个用户JSON格式2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// UserController.javapackage edu.xju.controller;import java.util.List;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import edu.xju.common.util.JsonUtil;import edu.xju.entity.User;import edu.xju.service.UserService;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; /** * 这个是返回页面 * @param model * @return */ @RequestMapping("/list.do") public String getUsers(Model model,HttpSession session)&#123; List&lt;User&gt; users = userService.getAll(); model.addAttribute("list",users); return "list"; &#125; /** * 获取json 的第一种方式 * 返回json 格式 * @param model * @param session * @param id * @return */ @RequestMapping("/getUserA.json") @ResponseBody public Object getUserByIdA(Model model,HttpSession session,Integer id )&#123; User user = userService.findUserById(id); return user; &#125; /** * 获取第json 的第二种方式 * @param model * @param response * @param session * @param id */ @RequestMapping("/getUserB.json") public void getUserByIdB(Model model,HttpServletResponse response,HttpSession session,Integer id )&#123; User user = userService.findUserById(id); JsonUtil.printByJSON(response, user); &#125; @RequestMapping("/addUser.do") public String insertUser(Model model,HttpSession session,Integer id,String name,Integer age )&#123; name = "测试姓名"; age = 99; User user = new User(name, age); userService.addUser(user); return "insertOK"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// User.javapackage edu.xju.entity;public class User &#123; private Integer id; private String name; private int age; public User() &#123; &#125; public User( String name, int age) &#123; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 12345678910111213// UserService.javapackage edu.xju.service;import java.util.List;import edu.xju.entity.User;public interface UserService &#123; public List&lt;User&gt; getAll(); public User findUserById(Integer id); public void addUser(User user); &#125; 1234567891011121314151617181920212223242526272829// UserServiceImpl.javapackage edu.xju.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import edu.xju.dao.UserMapper;import edu.xju.entity.User;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; public List&lt;User&gt; getAll()&#123; return userMapper.getAll(); &#125; @Override public User findUserById(Integer id) &#123; return userMapper.getUserById(id); &#125; @Override public void addUser(User user) &#123; userMapper.insertUser(user); &#125;&#125; MyBatis12345678910111213141516// UserMapper.javapackage edu.xju.dao;import java.util.List;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import edu.xju.entity.User;@Repositorypublic interface UserMapper &#123; public List&lt;User&gt; getAll(); public User getUserById(@Param("id")Integer id); public void insertUser(User user);&#125; 123456789101112131415161718192021// UserMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="edu.xju.dao.UserMapper" &gt; &lt;!-- 声明属性与查询字段之间的的对应关系 --&gt; &lt;resultMap id="BaseResultMap" type="edu.xju.entity.User" &gt; &lt;id column="id" property="id" jdbcType="INTEGER" /&gt; &lt;result column="name" property="name" jdbcType="VARCHAR" /&gt; &lt;result column="age" property="age" jdbcType="INTEGER" /&gt; &lt;/resultMap&gt; &lt;select id="getAll" resultMap="BaseResultMap"&gt; select id,name,age from user &lt;/select&gt; &lt;select id="getUserById" parameterType="int" resultMap="BaseResultMap"&gt; select id,name,age from user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="edu.xju.entity.User"&gt; insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3.序列图 4.常用注解解析：###@Autowired 和 @Resource的使用场景和区别(1) @Autowired 是byType自动注入，是Spring的注解。@Resource默认是byName注入，默认使用成员属性的变量名注入，是Java自带的注解。]]></content>
      <tags>
        <tag>JavaWEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计技巧]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[设计数据库的一些坑的总结。 1.Int与Integer的区别1234567891011121314151617181920/** * 学生 * 在使用Hibernate设计数据表声明数据类型时，Java代码中ID一般都设置成Integer类型，因为它可以默认为null，而 * 在使用性别时，一般都是使用Int类型 */@Entity@Table(name = "tb_student")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Student &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 年龄 private int age; // 性别 private int gender;&#125; 2.有依赖关联表与无依赖关联表一张表里只能有一个主键，或者有一种情况是one primary key included two fileds.有依赖关联表：通过在用户信息表里加入用户ID实现两张表的关联。 具体实现：逻辑模型物理模型 无依赖关联表：通过引入第三张表来进行用户表与用户信息表的关联。 3.Hibernate中一对一、一对多以及多对多的注解实现12345678910111213141516171819202122232425262728293031323334353637// 1:1 &lt;==&gt; Person:IdCard// Person.java@Entity@Table(name = "tb_person")public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 年龄 private int age; // 身份证 @OneToOne(mappedBy="person") //放弃维护主控权 private IdCard card;&#125;//IdCard.java@Entity@Table(name = "tb_idcard")public class IdCard &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 身份证号 private String sno; // 所属人 @OneToOne @JoinColumn(name="person_id", unique=true) private Person person;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 1:n &lt;==&gt; Department:Employee// Department.java@Entity@Table(name = "tb_dept")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Department &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 名称 @Column(length = 50) private String name; // 默认实体类所有字段都映射, 可使用@Transient声明不做映射 private int sn; // 拥有多个员工 @OneToMany(mappedBy = "dept") //mappedBy：表示放弃维护主控权 private Set&lt;Employee&gt; emps = new HashSet&lt;Employee&gt;();&#125;// Employee.java@Entity@Table(name="tb_emp")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Employee &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 部门 @ManyToOne @JoinColumn(name="dept_id") private Department dept;&#125; 123456789101112131415161718192021222324252627282930313233// n:n &lt;==&gt; Course:Student// Course.java@Entity@Table(name = "tb_course")public class Course &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 名称 private String name; // 学生 @ManyToMany @JoinTable(name="tb_student_course", joinColumns=@JoinColumn(name="course_id"), inverseJoinColumns=@JoinColumn(name="student_id")) private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();&#125;// Student.java@Entity@Table(name="tb_student")public class Student &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 课程 @ManyToMany(mappedBy="students") private Set&lt;Course&gt; courses = new HashSet&lt;Course&gt;();&#125;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基本操作]]></title>
    <url>%2F2017%2F08%2F01%2FGit-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git Bash的简单使用方法。 首先连接到国际互联网:123// 不需要的就不用了export http_proxy=&quot;http://127.0.0.1:1080/&quot;export https_proxy=&quot;http://127.0.0.1:1080/&quot; 1.创建代码仓库123456git config --global user.name &quot;String&quot;git config --global user.email &quot;xxx@gmail.com&quot;//建立代码仓库(在指定目录建立.git文件夹)git init 2.提交本地代码1234git add READEME.txt//在 -m 后面加上声明git commit -m &quot;Wrote a READEME file&quot;git push -u origin master 注释可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉！ 3.查看修改的内容12git diff//&quot;+&quot;号表示新增内容， &quot;-&quot;号表示删除的内容 4.查看提交记录1git log 此次提交对应的版本号 提交人：姓名 邮箱 提交的时间 提交版本修改的内容：就是我们commit -m “xxx”里的xxx 5.撤销未提交的更改1git checkout 文件路径 当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：12git reset HEAD 文件路径git checkout 文件路径 6.版本回退提交后回退到上一个版本 需要版本号 HEAD代表当前版本, HEAD^表示上一个版本, 以此类推 123git reset --hard HEADgit reset --hard HEAD^git log 如果你又后悔了1git reflog 键入版本号1git reset --hard 版本号(你要回退的版本号) 又会回到你期望的版本！ tips：(1)查看DNS记录的命令（A记录、MX记录）123yum install bind-utilsdig +noall +answer www.leezy.top (2) 查看端口常用命令：1netstat -lnp|grep 80 自动上传脚本:123456789#! /bin/bashecho 'start autodeployment...:)'hexo cleanecho 'hexo clean over...'hexo generateecho 'hexo generate over...'hexo deployecho 'hexo deploy over...'echo 'run success!:)']]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试-Java基础知识]]></title>
    <url>%2F2017%2F07%2F28%2F%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[扎实基础！18.3.5日更新：碰壁并吸取经验教训！ 笔试让我明白了自己的一些问题。123456byte a = 100;byte b = 10;byte c = a + b;// 报错 默认最低是Int类型byte c = (byte)a + b;int c = a + b; 1234567891011121314151617181920212223package com.lzy.test;public class Test1 &#123; public static void main(String[] args) &#123; int a = 0; int b = a++; System.out.println(a);//1 int c = ++a; System.out.println(a);//2 System.out.println(a++);//2 System.out.println(++a);//4 System.out.println(b);//0 System.out.println(c);//2 &#125;&#125;public static void main(String[] args) &#123; int a = 5; // a的变化：6 7 8 9 10 // b的变化： 5 7 7 8 10 int b = a++ + ++a + a++ + a++ + ++a; System.out.println(b); //37 &#125; 123456789101112131415161718public class Test2 &#123; public static void main(String[] args) &#123; int a = 0; //&amp;对每一个都判断； if (a==0 &amp; a++==1) &#123; System.out.println("&amp;");//不输出 &#125; System.out.println(a);//1 //&amp;&amp;只要前面是false就输出false，而不继续判断后面了 if (a==0 &amp;&amp; a++==1) &#123; System.out.println("&amp;&amp;");//不输出 &#125; if (a==1 &amp;&amp; a++==1) &#123; System.out.println("&amp;&amp;");//输出 &#125; &#125;&#125; 12345678910111213141516171819202122// 随机数 public static void main(String[] args) &#123; // 随机数产生的范围是[0, 1) double num = Math.random(); // 这样子[0, 0.5) [0.5, 1)才能真正平衡 if (num &gt;= 0.5) &#123; System.out.println("成都"); &#125; else &#123; System.out.println("赵雷"); &#125; // 输出指定范围的数字 // [26, 38] // 方法一： (int)(Math.random()*(max - min) + min); int a = 25; int b = 38; int scal = (int)(Math.random()*(b - a + 1)) + a; System.out.println(scal); // 方法二： int scall = (int)(Math.random() * 100 % 12) + a; System.out.println(scall); &#125; 基础知识点一：== 与 equal的区别： == 是一个运算符。 Equals则是string对象的方法，可以.（点）出来。 因为对象变量的存储的是对象在内存中的路径，即内存地址。所以用“==”比较时，即使对象的值相等，但是他们的内存地址不同(引用数据类型)，所以==的结果为false。故“==”用于比较两个变量的值是否相等，而不是变量引用的对象是否相等。 equal用于比较两个对象是否相同。 “==”比较的是值【变量(栈)内存中存放的对象的(堆)内存地址】equal用于比较两个对象的值是否相同【不是比地址】 【特别注意】Object类中的equals方法和“==”是一样的，没有区别，而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。”==”比”equal”运行速度快,因为”==”只是比较引用. 二：public、protected、private、default（friendly）的区别: public：可以被其他类访问private：只能被自己访问和修改protected:类内部、子类、同一个包中的类之间可以访问default：作用域是包，可以不写。被认为是friendly final关键字：修饰类：表示该类不能被继承，final类的所有成员方法都会被隐式的指定为final方法修饰方法：变是该方法不能被子类修改，类的private方法会被隐式的指定为final方法修饰变量：基本数据变量不可以被更改 引用类型变量不可以再更改指向另一个对象 Java线程安全与非线程安全：多线程安全优点体现在多个线程操作同一个对象，非线程安全 != 不安全线程安全是通过线程同步控制来实现的，也就是synchronized关键字。ArrayList是非线程安全 Vector是线程安全；HashMap是非线程安全 HashTable是线程安全；StringBuilder是非线程安全 StringBuffer是线程安全；http://blog.csdn.net/YiZhiCXY/article/details/51335385 String、StringBuffer、StringBuilder的区别：String： 字符串常量StringBuffer: 字符串变量（线程安全） 多线程下有优势StringBuilder: 字符串变量（非线程安全） 单线程下有优势 Array、ArrayList、Vectory、LinkedList的区别：(推荐看源码)ArrayList是为可变数组实现的，当更多的元素添加到ArrayList的时候，它的大小会动态增大。它的元素可以通过get/set方法直接访问，因为ArrayList本质上是一个数组。1234567891011121314/** * Resizable-array implementation of the &#123;@code List&#125; interface. Implements * all optional list operations, and permits all elements, including * &#123;@code null&#125;. In addition to implementing the &#123;@code List&#125; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list. (This class is roughly equivalent to * &#123;@code Vector&#125;, except that it is unsynchronized.) * &lt;p&gt;The &#123;@code size&#125;, &#123;@code isEmpty&#125;, &#123;@code get&#125;, &#123;@code set&#125;, * &#123;@code iterator&#125;, and &#123;@code listIterator&#125; operations run in constant * time. The &#123;@code add&#125; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;, * that is, adding n elements requires O(n) time. All of the other operations * run in linear time (roughly speaking). The constant factor is low compared * to that for the &#123;@code LinkedList&#125; implementation. */ LinkedList是为双向链表实现的,非线程安全(not )123456789101112131415161718/** * Doubly-linked list implementation of the &#123;@code List&#125; and &#123;@code Deque&#125; * interfaces. Implements all optional list operations, and permits all * elements (including &#123;@code null&#125;). * * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked * list. Operations that index into the list will traverse the list from * the beginning or the end, whichever is closer to the specified index. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked list concurrently, and at least * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more elements; merely setting the value of * an element is not a structural modification.) This is typically * accomplished by synchronizing on some object that naturally * encapsulates the list. */ Vector与ArrayList相似，但是它是同步的。12345678910111213141516/** * The &#123;@code Vector&#125; class implements a growable array of * objects. Like an array, it contains components that can be * accessed using an integer index. However, the size of a * &#123;@code Vector&#125; can grow or shrink as needed to accommodate * adding and removing items after the &#123;@code Vector&#125; has been created. * * &lt;p&gt;Each vector tries to optimize storage management by maintaining a * &#123;@code capacity&#125; and a &#123;@code capacityIncrement&#125;. The * &#123;@code capacity&#125; is always at least as large as the vector * size; it is usually larger because as components are added to the * vector, the vector's storage increases in chunks the size of * &#123;@code capacityIncrement&#125;. An application can increase the * capacity of a vector before inserting a large number of * components; this reduces the amount of incremental reallocation. */ 如果你的程序是线程安全的，ArrayList是一个比较好的选择。当更多的元素被添加的时候，Vector和ArrayList需要更多的空间。Vector每次扩容会增加一倍的空间，而ArrayList增加50%。 注意：ArrayList默认的初始空间大小相当的小，通过构造函数去初始化一个更大的空间是一个好习惯，可以避免扩容开销。部分引自于：https://www.cnblogs.com/chenpi/p/5505375.html Map、List、Set、Array的区别：https://www.cnblogs.com/chuanheliu/p/6363948.html Iterator 的hasNext方法和next方法:hasNext():如果仍有元素可以迭代，则返回 true。（换句话说，如果 next 返回了元素而不是抛出异常，则返回 true）。next():返回迭代的下一个元素。12345678910111213141516/** * Returns &#123;@code true&#125; if the iteration has more elements. * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would * return an element rather than throwing an exception.) * * @return &#123;@code true&#125; if the iteration has more elements */boolean hasNext();/** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */E next(); JAVA多线程和并发基础面试问答:http://www.cnblogs.com/dolphin0520/p/3932934.html Oracle数据库中TRUNCATE 与 DELETE 的区别： ROLLBACK可以撤销DELETE操作但撤销不了TRUNCATE操作 TRUNCATE TABLE比DELETE的速度快； TRUNCATE TABLE是删除表的所有行，而DELETE是删除表的一行或者多行 TRUNCATE TABLE在遇到任何一行违反约束(外键约束)时仍然删除表的所有行，但表的结构及其列、约束、索引等保持不变，DELETE则直接返回报错。 对于被外键约束的表，不能使用TRUNCATE TABLE，而应该使用不带WHERE语句的DELETE语句。 如果想保留标识计数值，要用DELETE，因为TRUNCATE TABLE会对新行标志符列搜用的计数值重置为该列的种子。 ###序列化的作用：为了保存在内存中的各种对象的状态（序列化），并且可以把保存的对象状态再读出来（反序列化）。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2017%2F07%2F27%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[今年7月中旬，我来到了成都，见识到了成都的美。 成都 让我掉下眼泪的 不止昨夜的酒 让我依依不舍的 不止你的温柔 余路还要走多久 你攥着我的手 让我感到为难的 是挣扎的自由 分别总是在九月 回忆是思念的愁 深秋嫩绿的垂柳 亲吻着我额头 在那座阴雨的小城里 我从未忘记你 成都 带不走的 只有你 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 分别总是在九月 回忆是思念的愁 深秋嫩绿的垂柳 亲吻着我额头 在那座阴雨的小城里 我从未忘记你 成都 带不走的 只有你 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
