<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程与高并发]]></title>
    <url>%2F2019%2F11%2F30%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[并发编程的基础、并发模拟工具及代码。 并发编程的基础 CPU多级缓存 时间局部性 空间局部性缓存一致性： M E S I 用于保证多个CPU Cache之间共享数据的一致M 修改状态E 独享状态S 共享状态I 无效状态 乱序执行优化 为了提高运算速度而做出违背代码原有顺序的优化 JAVA内存模型 (Java Memory Model - JMM) Heap 堆可动态分配内存大小，生存期不需事先告诉编译器，存取速度慢，常用于存放对象Thread Stack 栈存取速度快，仅次于寄存器，数据大小和生存期必须确定，常用于存取基本类型变量，本地变量 栈上的引用变量数据可以访问引用的堆对象，如果两个线程同时调用了同一个对象，都会访问成员变量，但是这两个线程会有自己变量的私有拷贝。 每个线程都有自己的“本地内存”，Java中线程的“本地内存”指的是CPU寄存器和高速缓存的抽象描述。两个线程之间的变量共享是要通过主内存的。 Java内存模型-同步八种操作 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中以便随后的load动作使用。 load（载入）: 作用于工作内存的变量,它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量,把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量,它把一个从执行引擎接收到的值赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中,以便随后的write的操作 write（写入）：作用于主内存的变量,它把store操作从工作内存中一个变量的值传送到主内存的变量中 工作规则： 如果要把一个变量从主内存中复制到工作内存,就需要按顺序地执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行,而没有保证必须是连续执行。 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作,即变量在工作内存中改变了之后必须同步到主内存中 不允许—个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或assign )的变量。即就是对一个变量实施use和store操作之前,必须先执行过了assign和load操作 一个变量在同_时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次,多次执行lock后,只有执行相同次数的unlock操作,变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生/不允许在工作内存中直接使用一个未被初始化（load或assign ）的变量。即就是对一个变量实施use和store操作之前, 必须先执行过了assign和load操作 并发模拟工具及代码:工具： PostMan Apache Bench Apache JMeter 代码： CountDownLatch - 闭锁：1. await() 2. countDown() 阻塞线程，满足某种特定的条件继续执行，常与与线程池一同使用。 Semaphore - 信号量：可以阻塞线程，控制同一时间请求的并发量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.leezy.concurrency;import com.leezy.concurrency.annoations.NotThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * @program: spring-cloud-leezy * @description: 测试并发 * @author: LEEZY * @create: 2019-11-30 16:03 **/@Slf4j@NotThreadSafe// count:4962 结果不准确，线程不安全public class ConcurrencyTest &#123; // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static int count = 0; private static void add() &#123; count++; &#125; public static void main(String[] args) throws InterruptedException &#123; // 线程池 ExecutorService executorService = Executors.newCachedThreadPool(); // 信号量以及并发线程数 final Semaphore semaphore = new Semaphore(threadTotal); // 计数器-闭锁 放入请求总数 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; // 根据并发的限制数量, 判断当前线程是否允许被执行 semaphore.acquire(); add(); // 释放线程 semaphore.release(); &#125; catch (InterruptedException e) &#123; log.error("exception", e); &#125; // 执行一次就进行releaseShared countDownLatch.countDown(); &#125;); &#125; // 这个方法可以保证 countDown 减为0 countDownLatch.await(); // 关闭线程池 executorService.shutdown(); log.info("count:" + count); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2019%2F10%2F08%2FMySQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[MySQL的优化方法。 MySQL的标准执行顺序从上到下： FROM ON JOIN WHERE GROUP BY WITH {CUBE|ROLLUP} HAVING SELECT DISTINCT ORDER BY LIMIT]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-从入门到精通]]></title>
    <url>%2F2019%2F09%2F29%2FGit-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[Git Bash的简单使用方法。 git 可以分三个区： 工作区(注解编辑页面)，就是本地文件夹。暂存区(数据暂时存放的位置，可以在工作区和版本库之间进行数据的友好交流)，git add 命令将他们添加到暂存区。版本库/本地仓库(存放已经提交的数据，push的时候，就是将这个区的数据push到远程仓库了)，git commit 命令则将暂存区中的文件提交到本地仓库中。 首先连接到国际互联网: 123# 不需要的就不用了export http_proxy="http://127.0.0.1:1080/"export https_proxy="http://127.0.0.1:1080/" 创建代码仓库123456git config --global user.name "SAKURA"git config --global user.email "xxx@gmail.com"# 建立代码仓库(在指定目录建立.git文件夹)git init# 查看代码仓库状态git status 提交本地代码123456789git add READEME.txt# 全部更新到暂存区git add .# 在 -m 后面加上声明, 将代码提交到本地仓库git commit -m "Wrote a READEME file"# 如果要求的提交备注特别多,可以打开一个vi编辑器git commit# 从本地仓库提交到远程仓库master分支git push -u origin master 注释可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉！ 分支的建立早建分支, 多用分支 123456# 建立分支git branch newImage# 切换到新分支 newImagegit checkout newImage;# 新分支代码提交git commit 上面的操作可以简化为下面两步 1234# 创建新的分支并切换到新分支git checkout -b newImage# 新分支代码提交git commit 分支的合并方法一：Merge 123456789101112# 建立新的分支bugFixgit branch bugFix# 切换到bugFix分支git checkout bugFix# bugFix代码提交git commit# 切换到master分支git checkout master# master分支代码提交git commit# 分支合并 - 现在master分支上有了bugFix的提交git merge bugFix 方法二：Rebase简单来说Rebase就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个将修改放下去，这样的好处是会使代码库的提交历史变得清晰。 123456# 假设当前是在bugFix分支下，将bugFix分支的工作直接移动到master分支上git rebase master# 切换到master分支git checkout master# 将master分支的引用向前移动，即rebase到bugFixgit rebase bugFix 在提交树上移动HEAD 总是指向当前分支上最近一次提交记录，HEAD通常是指向分支名的,但是可以通过git checkout &lt;哈希值&gt;来将HEAD指向一个具体的提交记录。 12345678# 查看HEAD指向的两种方式cat .git/HEAD# 如若HEAD指向的是一个引用git symbolic-ref HEAD # 分离的HEAD，为了让其指向某个具体的提交记录而不是分支名 注：这里的Hash值并不需要全部40位，# 能表示出唯一标识的前6位字符就可以git checkout &lt;提交记录的哈希值&gt;` 为了避免使用git log命令查看Hash值，再通过git checkout命令分离HEAD，所以有了相对引用 ^ 表示向上移动一个提交记录 123git checkout HEAD^# 或者git checkout master^ ~&lt;num&gt;表示向上移动多个提交记录, num为1时等价与^ 1234# 寻找指定提交记录的父提交git checkout HEAD~3# 或者git checkout master~3 相对引用最常见的地方就是用来移动分支 12# 将master分支移到HEAD所指分支位置前三个节点git branch -f master HEAD~3 撤销变更方法一：git reset - 仅限在本地分支中使用 12# 把分支记录回退几个提交记录来实现撤销改动,最新的提交变成了未加入暂存区状态git reset HEAD~1 方法二：git revert - 适用于提交到了远程分支 12# 会在远程添加一个新的提交记录，用来抵消掉远程仓库最新的更改git revert HEAD 提交记录的整理 将一些提交复制到当前所在的位置（HEAD）的下面，cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD上（只要不是HEAD上游的提交就没有问题） 12# git cherry-pick &lt;提交号&gt;...git cherry-pick d4b052 4aa0aa 交互式的rebase 你可以通过给git rebase增加-i选项来以交互方式地运行rebase。你必须通过告诉命令衍合到哪次提交，来指明你需要重写的提交的回溯深度。 12# 这是一个衍合命令——HEAD~2..HEAD范围内的每一次提交都会被重写，无论你是否修改说明。git rebase -i HEAD~2 上述命令会打开一个交互窗口： 很重要的一点是你得注意这些提交的顺序与你通常通过log命令看到的是相反的。 通过rebase UI界面, 你能做3件事: 调整提交记录的顺序 删除你不想要的提交 合并提交, 把多个提交记录合并成一个。 详情请看这里 查看修改的内容1234# "+"号表示新增内容， "-"号表示删除的内容git diff# 可视化的查看方法git difftool 查看提交记录1git log 此次提交对应的版本号 提交人：姓名 邮箱 提交的时间 提交版本修改的内容：就是我们commit -m “xxx”里的xxx 记住密码1git config --global credential.helper store 版本回退提交后回退到上一个版本 需要版本号 HEAD代表当前版本, HEAD^表示上一个版本, 以此类推 1234567# 查看版本号git log git reset --hard f37911a60ca123c86c712ff0539619902a7375e8(目标版本号)git reset --hard HEADgit reset --hard HEAD^git log 如果你又后悔了 1git reflog 键入版本号 1git reset --hard 版本号(你要回退的版本号) 又会回到你期望的版本！ GitHub 初始化提交 create a new repository on the command line 1234567echo "# NOTES" &gt;&gt; README.mdgit init# git add .git add README.mdgit commit -m "first commit"git remote add origin https://github.com/XXX/NOTES.gitgit push -u origin master push an existing repository from the command line 12git remote add origin https://github.com/XXX/NOTES.gitgit push -u origin master 自动上传脚本:123456789#! /bin/bashecho 'start autodeployment...:)'hexo cleanecho 'hexo clean over...'hexo generateecho 'hexo generate over...'hexo deployecho 'hexo deploy over...'echo 'run success!:)' 常用操作场景：本地新建了一个新的文件夹，想拉取远程的一个项目 1234567git initgit remote add origin https://github.com/XXX/NOTES.git# git pull &lt;remote&gt; &lt;branch&gt; 直接指定远程mastergit pull origin master# 先指定本地master到远程的master，然后再去pullgit branch --set-upstream-to=origin/master mastergit pull 场景：将本地的.git文件删除了，本地文件也更新了，新建git仓库和远程合并 123456789101112git initgit remote add origin https://github.com/XXX/NOTES.git# 会报错，failed to push some refs to ...git push origin master# 这个时候需要先拉取远程的项目git pull origin master# 然后会报错，fatal: refusing to merge unrelated historiesgit pull origin master --allow-unrelated-histories# 然后按照要求解决冲突就好，再commit一下git add .git commit -m "fix conflicts"git push origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础知识-Map]]></title>
    <url>%2F2019%2F09%2F09%2FJAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Map%2F</url>
    <content type="text"><![CDATA[JAVA基础知识-Map 相关知识。 遍历Map 方法一： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SlowMap &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("A", "01"); map.put("B", "02"); map.put("C", "03"); // 获取键的集合 Set&lt;String&gt; keySet = map.keySet(); // 利用set集合的迭代器 Iterator&lt;String&gt; iterator = keySet.iterator(); while(iterator.hasNext()) &#123; String key = iterator.next(); String value = map.get(key); System.out.println("MAP INFO KEY:" + key + " VALUE:" + value); &#125; &#125;&#125;``` &gt; 方法二：```javapublic class QuickMap &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("A", "01"); map.put("B", "02"); map.put("C", "03"); // 通过entrySet()方法将map集合中的映射关系取出 Set&lt;Map.Entry&lt;String, String&gt;&gt; entry = map.entrySet(); // 利用关系集合entrySet的迭代器 Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entry.iterator(); while(iterator.hasNext()) &#123; // 获取Map.Entry的关系对象me Map.Entry&lt;String, String&gt; me = iterator.next(); // 通过关系对象获取key String key = me.getKey(); // 通过关系对象获取value String value = me.getValue(); System.out.println("Key :" + key + " value :" + value); &#125; &#125;&#125; 方法三： 1234567891011121314151617public class CollectionMap &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("A", "01"); map.put("B", "02"); map.put("C", "03"); // Collection集合存放Map的value值 Collection&lt;String&gt; collection = map.values(); // 遍历Collection Iterator&lt;String&gt; it = collection.iterator(); // 只能遍历value值，不能遍历key值 while(it.hasNext()) &#123; Object value = it.next(); System.out.println(value); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础知识-HashMap]]></title>
    <url>%2F2019%2F09%2F05%2FJAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-HashMap%2F</url>
    <content type="text"><![CDATA[JAVA基础知识-HashMap 相关知识。 常用的通配符T, E, K, V, ? 本质上没有任何区别，但是为了维持可读性，常这样约定： ？表示不确定的JAVA类型 T (type) 表示一个具体的JAVA类型 K V (key value) 分别表示JAVA键值对 key - value E (element) 代表Element RBT(红黑树) 每个节点是红色或者黑色 根节点是黑色 每个叶节点是黑色的 如果一个节点是红色的，则它的两个儿子都是黑色的 对于每个节点，从该结点到其叶子节点构成的所有路径上的黑色结点个数相同 插入过程： 默认插入节点为红色 AVL(自平衡二叉查找树) 首先是一棵二叉查找树 某节点的左子树节点值仅包含小于该节点值 某节点的右子树节点值仅包含大于该节点值 左右子树每个也必须是二叉查找树 带有平衡条件，每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1 RBT和AVL查找远远多于插入删除，选择AVL树 如果查找、插入、删除频率差不多，那么选择红黑树 JAVA 中红黑树的实现12345678910static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125;&#125; 红黑树的插入过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; // 初始染色为红 x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; // 插入的为根节点（父节点为空），则直接把颜色改为黑色 if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; // 父节点为黑色节点或者插入节点的祖父节点为空，则直接返回 else if (!xp.red || (xpp = xp.parent) == null) return root; // I. 父节点和祖父节点都存在且父节点是祖父节点的左节点 if (xp == (xppl = xpp.left)) &#123; // 1. 祖父节点的右节点（叔叔节点）不是空且为红色 if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; // 将叔叔节点改为黑色 xppr.red = false; // 将父亲节点改为黑色 xp.red = false; // 将祖父节点改为红色 xpp.red = true; x = xpp; &#125; // 2. 祖父节点的右节点（叔叔节点）是空或者为黑色 else &#123; // 插入节点是父节点的右孩子，将父节点左旋 if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; // 插入节点是父节点的左孩子 if (xp != null) &#123; // 将父节点变成黑色节点 xp.red = false; if (xpp != null) &#123; // 祖父节点变成红色节点，然后将祖父节点右旋 xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; // II. 父节点和祖父节点都存在且父节点是祖父节点的右节点 else &#123; // 1. 祖父节点的左节点（叔叔节点）不为空且为红色 if (xppl != null &amp;&amp; xppl.red) &#123; // 将叔叔节点改为黑色 xppl.red = false; // 将父亲节点改为黑色 xp.red = false; // 将祖父节点改为红色 xpp.red = true; x = xpp; &#125; // 2. 祖父节点的左节点（叔叔节点）是空或者为黑色 else &#123; // 插入节点是父节点的左孩子，将父节点右旋 if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; // 插入节点是父节点的右孩子 if (xp != null) &#123; // 将父节点变成黑色节点 xp.red = false; if (xpp != null) &#123; // 祖父节点变成红色节点，然后将祖父节点左旋 xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125;&#125; 左旋右旋方法： 123456789101112131415161718192021222324252627282930313233static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root;&#125;static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root;&#125; 红黑树的删除过程： 先进行二叉搜索树的删除 然后进行红黑树的调整 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// p是待删除节点，replacement用于后续的红黑树调整，指向的是p或者p的继承者。if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p;&#125;else if (pl != null) replacement = pl;else if (pr != null) replacement = pr;else replacement = p;if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null;&#125;// 如果删除时的节点p是红色，则树平衡不会被破坏，无需调整。 TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125;&#125;if (movable) moveRootToFront(tab, r); 删除后的调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// root : 根节点 | x : 根节点的继承者static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; // 如果x为空或x为根节点，直接返回 if (x == null || x == root) return root; // x为根节点，染成黑色，直接返回(删除的为根节点，则扶植继承者x为新的根节点) else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; // x为红色，则无需调整，直接返回根节点 else if (x.red) &#123; x.red = false; return root; &#125; // x为其父节点的左孩子 else if ((xpl = xp.left) == x) &#123; // 如果x有红色兄弟节点xpr, 则它的父节点xp一定是黑色节点 if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; // 将父节点左旋 root = rotateLeft(root, xp); // 重新将xp指向x的父节点，xpr指向xp新的右孩子 xpr = (xp = x.parent) == null ? null : xp.right; &#125; //如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环 if (xpr == null) x = xp; else &#123; // sl和sr分别为其近侄子和远侄子 TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; // 若s1和s2都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红 if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; // 继续向上循环 x = xp; &#125; else &#123; // 右孩子为空或者为黑色 if (sr == null || !sr.red) &#123; // 有左孩子则染黑 if (sl != null) sl.red = false; // 将xpr染红 xpr.red = true; // xpr右旋 root = rotateRight(root, xpr); // 右旋后xpr指向xp的新右孩子，即上面的s1 xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; // xpr染成跟父节点一致的颜色，为后面父节点xp的左旋做准备 if ((sr = xpr.right) != null) xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) // xpr新的右孩子染黑，防止出现两个红色相连 sr.red = false; &#125; if (xp != null) &#123; // 将xp染黑，并对其左旋，这样就能保证被删除的X所在的路径又多了一个黑色节点，从而达到恢复平衡的目的 xp.red = false; root = rotateLeft(root, xp); &#125; // 到此调整已经完毕，进入下一次循环后将直接退出 x = root; &#125; &#125; &#125; // x为其父节点的右孩子... else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125;&#125; 重写HashCode()方法和Equals()方法1234567891011121314151617// Prediction.javaimport java.util.Random;public class Prediction &#123; private static Random rand = new Random(47); private boolean shadow = rand.nextDouble() &gt; 0.5; public String toString() &#123; if (shadow) &#123; return "Six more weeks of Winner!"; &#125; else &#123; return "Early Spring"; &#125; &#125;&#125; 123456789101112// Groundhog.javapublic class Groundhog &#123; protected int number; public Groundhog(int n) &#123; number = n; &#125; public String toString() &#123; return "Groundhog #" + number; &#125;&#125; 123456789101112131415161718192021222324252627282930313233// SpringDetector.javaimport java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class SpringDetector &#123; // 利用反射机制获取构造函数 public static &lt;T extends Groundhog&gt; void detectSpring(Class&lt;T&gt; type) throws Exception &#123; Constructor&lt;T&gt; ghog = type.getConstructor(int.class); Map&lt;Groundhog, Prediction&gt; map = new HashMap&lt;Groundhog, Prediction&gt;(); for (int i = 0; i &lt; 10; i++) &#123; map.put(ghog.newInstance(i), new Prediction()); &#125; System.out.println("MAP" + map); Groundhog groundhog = ghog.newInstance(3); System.out.println("Looking up prediction for" + groundhog); if (map.containsKey(groundhog)) &#123; System.out.println(map.get(groundhog)); &#125; else &#123; System.out.println("Key not found:" + groundhog); &#125; &#125; public static void main(String[] args) throws Exception &#123; detectSpring(Groundhog.class); &#125;&#125; Output: 123MAP&#123;Groundhog #1=Six more weeks of Winner!, Groundhog #4=Six more weeks of Winner!, Groundhog #5=Early Spring, Groundhog #3=Early Spring, Groundhog #8=Six more weeks of Winner!, Groundhog #7=Early Spring, Groundhog #0=Six more weeks of Winner!, Groundhog #2=Early Spring, Groundhog #9=Six more weeks of Winner!, Groundhog #6=Early Spring&#125;Looking up prediction forGroundhog #3Key not found:Groundhog #3 Groundhog默认调用的是基类Object的hashCode方法，默认使用的是对象的地址计算的散列码。同时只重写hashCode()方法是不够的，还需要重写equals()方法。 补充一句，hashCode()是基类Object的方法，所有Java对象都能产生散列码。 12345678910111213// Groundhog2.javapublic class Groundhog2 extends Groundhog &#123; public Groundhog2(int n) &#123; super(n); &#125; public int hashCode() &#123; return number; &#125; public boolean equals(Object object) &#123; return object instanceof Groundhog2 &amp;&amp; (number == ((Groundhog2)object).number); &#125;&#125; 123456// SpringDetector2.javapublic class SpringDetector2 &#123; public static void main(String[] args) throws Exception &#123; SpringDetector.detectSpring(Groundhog2.class); &#125;&#125; Output: 123MAP&#123;Groundhog #0=Six more weeks of Winner!, Groundhog #1=Six more weeks of Winner!, Groundhog #2=Early Spring, Groundhog #3=Early Spring, Groundhog #4=Six more weeks of Winner!, Groundhog #5=Early Spring, Groundhog #6=Early Spring, Groundhog #7=Early Spring, Groundhog #8=Six more weeks of Winner!, Groundhog #9=Six more weeks of Winner!&#125;Looking up prediction forGroundhog #3Early Spring]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[データとの絆]]></title>
    <url>%2F2019%2F08%2F15%2FTHE_DATA_ANALYSIS%2F</url>
    <content type="text"><![CDATA[もう一回もう一回行こうぜ 僕らの声 アイムアルーザー ずっと前から聞こえてた 准备工作1init_woody Matplotlib env init complete. Warnings off.1234import pandas as pdimport numpy as npimport seaborn as snsimport matplotlib.pyplot as plt 12# 不省略行的查看数据pd.set_option('display.max_columns', 200) 数据源准备1234567891011121314151617181920212223242526272829303132333435363738# 导入train数据train_idv_td = pd.read_csv("../data/2/train/IDV_TD.csv", encoding='utf-8') # 个人定期存款账户信息（IDV_TD）train_idv_dpsa = pd.read_csv("../data/2/train/IDV_DPSA.csv", encoding='utf-8') # 个人活期存款账户信息（IDV_DPSA）train_loan = pd.read_csv("../data/2/train/LOAN.csv", encoding='utf-8') # 贷款账户信息（LOAN）train_bond = pd.read_csv("../data/2/train/BOND.csv", encoding='utf-8') # 国债账户信息（BOND）train_fund = pd.read_csv("../data/2/train/FUND.csv", encoding='utf-8') # 基金账户信息（FUND）train_prec_metal = pd.read_csv("../data/2/train/PREC_METAL.csv", encoding='utf-8') # 贵金属账户信息（PREC_METAL）train_aget_insr = pd.read_csv("../data/2/train/AGET_INSR.csv", encoding='utf-8') # 代理保险账户信息（AGET_INSR）train_thr_pty_cstd = pd.read_csv("../data/2/train/THR_PTY_CSTD.csv", encoding='utf-8') # 第三方存管账户信息（THR_PTY_CSTD）train_idv_cust_basic = pd.read_csv("../data/2/train/IDV_CUST_BASIC.csv", encoding='utf-8') # 个人客户基本信息（IDV_CUST_BASIC）train_tr_dc = pd.read_csv("../data/2/train/TR_DC.csv", encoding='utf-8') # 交易信息（TR_DC）train_base_excg = pd.read_csv("../data/2/train/BASE_EXCG.csv", encoding='utf-8') # 汇率表（BASE_EXCG）train_cust_result = pd.read_csv("../data/2/train/CUST_RESULT.csv", encoding='utf-8') # 客户标记（CUST_RESULT）# A榜# BASE_EXCG.csv 无A_idv_td = pd.read_csv("../data/2/A/IDV_TD.csv", encoding='utf-8')A_idv_dpsa = pd.read_csv("../data/2/A/IDV_DPSA.csv", encoding='utf-8')A_loan = pd.read_csv("../data/2/A/LOAN.csv", encoding='utf-8')A_bond = pd.read_csv("../data/2/A/BOND.csv", encoding='utf-8')A_fund = pd.read_csv("../data/2/A/FUND.csv", encoding='utf-8')A_prec_metal = pd.read_csv("../data/2/A/PREC_METAL.csv", encoding='utf-8')A_aget_insr = pd.read_csv("../data/2/A/AGET_INSR.csv", encoding='utf-8')A_thr_pty_cstd = pd.read_csv("../data/2/A/THR_PTY_CSTD.csv", encoding='utf-8')A_idv_cust_basic = pd.read_csv("../data/2/A/IDV_CUST_BASIC.csv", encoding='utf-8')A_tr_dc = pd.read_csv("../data/2/A/TR_DC.csv", encoding='utf-8')A_customid = pd.read_csv("../data/2/A/CUSTOMID.csv", encoding='utf-8')# B榜B_idv_td = pd.read_csv("../data/2/B/IDV_TD.csv", encoding='utf-8')B_idv_dpsa = pd.read_csv("../data/2/B/IDV_DPSA.csv", encoding='utf-8')B_loan = pd.read_csv("../data/2/B/LOAN.csv", encoding='utf-8')B_bond = pd.read_csv("../data/2/B/BOND.csv", encoding='utf-8')B_fund = pd.read_csv("../data/2/B/FUND.csv", encoding='utf-8')B_prec_metal = pd.read_csv("../data/2/B/PREC_METAL.csv", encoding='utf-8')B_aget_insr = pd.read_csv("../data/2/B/AGET_INSR.csv", encoding='utf-8')B_thr_pty_cstd = pd.read_csv("../data/2/B/THR_PTY_CSTD.csv", encoding='utf-8')B_idv_cust_basic = pd.read_csv("../data/2/B/IDV_CUST_BASIC.csv", encoding='utf-8')B_tr_dc = pd.read_csv("../data/2/B/TR_DC.csv", encoding='utf-8')B_customid = pd.read_csv("../data/2/B/CUSTOMID.csv", encoding='utf-8') /root/anaconda3/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2728: DtypeWarning: Columns (12) have mixed types. Specify dtype option on import or set low_memory=False. interactivity=interactivity, compiler=compiler, result=result)1234567# 把汇率表中的CCY_LETE_CD字段转化为CCY_CD字段train_base_excg = pd.read_csv("../data/2/train/BASE_EXCG.csv", encoding='utf-8') # 汇率表（BASE_EXCG）train_base_excg['CCY_CD'] = train_base_excg['CCY_LETE_CD']train_base_excg = train_base_excg.drop(['CCY_LETE_CD'], axis=1)train_base_excg['RMB_MID_PRIC'].apply(lambda x: float(x))# 把汇率表中的CCY_LETE_CD字段转化为CCY_CD字段train_tr_dc['TR_DAT'].apply(lambda x: int(x)) 公用函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 按汇率计算价值（传入2个参数返回计算结果）def compute_REAL_MONEY(train_IDV_DPSA_SAMPLE, A, B): NEED = train_IDV_DPSA_SAMPLE[A] RMB_MID_PRIC = train_IDV_DPSA_SAMPLE[B] return NEED * float(RMB_MID_PRIC)# one-hot 处理函数# 本地评价def evaluate(test_y, y_pred): from sklearn import metrics test_pct_1 = test_y.sum()/test_y.shape[0] pred_pct_1 = y_pred.sum()/y_pred.shape[0] roc_auc = metrics.roc_auc_score(test_y,y_pred) acc = metrics.accuracy_score(test_y,y_pred) Recall = metrics.recall_score(test_y,y_pred) F1 = metrics.f1_score(test_y,y_pred) Precision = metrics.precision_score(test_y,y_pred) Confusion = metrics.confusion_matrix(test_y,y_pred) print ('test_pct_1: %.4f' % test_pct_1) print ('pred_pct_1: %.4f' % pred_pct_1) print ('Precesion: %.4f' % Precision) print ('Recall: %.4f' % Recall) print ('F1-score: %.4f' % F1) print('confusion matrix:') print (metrics.confusion_matrix(test_y,y_pred)) return &#123;'test_pct_1':test_pct_1,'pred_pct_1':pred_pct_1,'roc_auc':roc_auc,'acc':acc,'recall':Recall,'F1':F1,'Precision':Precision,'Confusuion':Confusion&#125;def feature_rank(model,num): ##计算特征得分 feature_score = model.get_fscore() df_feature_score = pd.DataFrame(&#123;"feature_name":list(feature_score.keys()),"feature_score":list(feature_score.values())&#125;) df_feature_score_sort = df_feature_score.sort_values(ascending=0,by=['feature_score']) #result_name = "feature_score_1_A_%s_%s_%s_%6f.csv"%(time_str,feature_num,train_steps,F1_score) #result_name_full = datas_dir_e + "out/" + result_name #df_feature_score_sort.to_csv(result_name_full,index=None) return df_feature_score_sort.head(num)def stat_df(df): stats = [] for col in df.columns: stats.append((col, df[col].nunique(),df[col].isnull().sum()*100/df.shape[0], df[col].value_counts(normalize=True,dropna=False).values[0]*100,df[col].dtype)) stats_df = pd.DataFrame(stats, columns=['特征','唯一数数量','缺失值占比','最多数占比','类型']) stats_df.sort_values('缺失值占比',ascending=False) return stats_dfdef plot_feature_distribution(df1,df2,label1,label2,features,width=6,height=6): i=0 sns.set_style('whitegrid') plt.figure() fig,ax = plt.subplots(width,height,figsize=(20,12)) for feature in features: i+=1 plt.subplot(width,height,i) sns.kdeplot(df1[feature],bw=0.5,label=label1) sns.kdeplot(df2[feature],bw=0.5,label=label2) plt.xlabel(feature,fontsize=9) locs, labels = plt.xticks() plt.tick_params(axis='x',which='major',labelsize=6,pad=-6) plt.tick_params(axis='y',which='major',labelsize=6) plt.show() 特征工程个人客户基本信息表(IDV_CUST_BASIC) - 处理1234567# 删除没用的字段train_idv_cust_basic_SAMPLE = train_idv_cust_basic.drop(['DATA_DAT', 'PROV_CD', 'CUST_SEX_CD', 'RES_CD', 'RES_STA_CD', 'NATY_CD', 'NATN_CD', 'CULT_DGR_CD', 'DGR_CD', 'PLC_STS_CD', 'PRFN', 'ADMI_POS_CD', 'SPEC_TECH_PRFN_QUA_CD', 'TITLE_RANK_CD', 'WORK_TYP_CD', 'GC_BRTH', 'UNIT_PROP_CD', 'WORK_YEAR', 'OCP_CD'], axis=1)# 将个人客户基本信息表与结果整合train_idv_cust_basic_SAMPLE = pd.merge(train_idv_cust_basic_SAMPLE, train_cust_result, on='CUST_NO') 12345features = [x for x in train_idv_cust_basic_SAMPLE.columns if x not in ['CUST_NO','FLAG']]df0 = train_idv_cust_basic_SAMPLE[train_idv_cust_basic_SAMPLE.FLAG==0]df1 = train_idv_cust_basic_SAMPLE[train_idv_cust_basic_SAMPLE.FLAG==1]plot_feature_distribution(df0,df1,'0','1',features,2,2) /root/anaconda3/lib/python3.6/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won&apos;t work for two columns. /root/anaconda3/lib/python3.6/site-packages/statsmodels/nonparametric/kde.py:454: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X&gt;clip[0], X&lt;clip[1])] # won&apos;t work for two columns. &lt;matplotlib.figure.Figure at 0x7f0167e93dd8&gt; 12345678# 声明函数def IDV_CUST_BASIC_PARSE(dataset_IDV_CUST_BASIC): # 删除个人用户信息表中无关元素 dataset_IDV_CUST_BASIC = dataset_IDV_CUST_BASIC.drop(['DATA_DAT', 'PROV_CD', 'CUST_SEX_CD', 'RES_CD', 'RES_STA_CD', 'NATY_CD', 'NATN_CD', 'CULT_DGR_CD', 'DGR_CD', 'PLC_STS_CD', 'PRFN', 'ADMI_POS_CD', 'SPEC_TECH_PRFN_QUA_CD', 'TITLE_RANK_CD', 'WORK_TYP_CD', 'GC_BRTH', 'UNIT_PROP_CD', 'WORK_YEAR', 'OCP_CD'], axis=1) return dataset_IDV_CUST_BASIC 个人定期存款账户信息（IDV_TD）- 处理12# 查看数据比例stat_df(train_idv_td) 12345678910111213141516171819202122232425262728# 编成函数def IDV_TD_PARSE(dataset_IDV_TD): train_idv_td_3 = dataset_IDV_TD[dataset_IDV_TD['DATA_DAT']==3734035200] # 简化IDV_TD表 train_idv_td_3 = train_idv_td_3.drop(['DATA_DAT', 'ARG_CRT_DAT', 'DATA_DAT', 'CLS_ACCT_DAT', 'MATU_DAT', 'LAC', 'ACCT_STS_CD','DP_DAY_CD', 'RDEP_IND_CD', 'RDEP_DP_DAY_CD', 'RAT_CTG','FXDI_SA_ACCM', 'MTH_ACT_DAYS_TOT'], axis=1) # 去重 train_idv_td_3.drop_duplicates(subset=None, keep='first', inplace=True) # 将train_idv_td和train_base_excg合并 train_IDV_TD_SAMPLE_3 = pd.merge(train_idv_td_3, train_base_excg, on = 'CCY_CD') # 执行汇率计算函数 train_IDV_TD_SAMPLE_3['CRBAL'] = train_IDV_TD_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('CRBAL', 'RMB_MID_PRIC')) train_IDV_TD_SAMPLE_3['REG_CAP'] = train_IDV_TD_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('REG_CAP', 'RMB_MID_PRIC')) train_IDV_TD_SAMPLE_3['FXDI_T_ACCM'] = train_IDV_TD_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('FXDI_T_ACCM', 'RMB_MID_PRIC')) train_IDV_TD_SAMPLE_3['TDOP_SHD_PAY_INTS'] = train_IDV_TD_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('TDOP_SHD_PAY_INTS', 'RMB_MID_PRIC')) train_IDV_TD_SAMPLE_3['MOTH_CR_ACCM'] = train_IDV_TD_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('MOTH_CR_ACCM', 'RMB_MID_PRIC')) train_IDV_TD_SAMPLE_3['IDV_TD_SUM'] = train_IDV_TD_SAMPLE_3['TDOP_SHD_PAY_INTS'] + train_IDV_TD_SAMPLE_3['REG_CAP'] # 再次精简表 train_IDV_TD_SAMPLE_3 = train_IDV_TD_SAMPLE_3.drop(['CCY_CD', 'RMB_MID_PRIC'], axis=1) # 数据去重 train_IDV_TD_SAMPLE_3.drop_duplicates(subset=None, keep='first', inplace=True) # 将个人账户里的数据合并即金额加起来 train_IDV_TD_SAMPLE_SUM_3 = train_IDV_TD_SAMPLE_3[['CUST_NO', 'CRBAL', 'REG_CAP', 'FXDI_T_ACCM', 'TDOP_SHD_PAY_INTS', 'MOTH_CR_ACCM', 'IDV_TD_SUM']].groupby('CUST_NO').sum().reset_index() # 区分字段 train_IDV_TD_SAMPLE_SUM_3 = train_IDV_TD_SAMPLE_SUM_3.rename(columns=&#123;'CRBAL':'IDV_TD_CRBAL', 'MOTH_CR_ACCM':'IDV_TD_MOTH_CR_ACCM'&#125;) # @ 去除过分关联的特征 train_IDV_TD_SAMPLE_SUM_3 = train_IDV_TD_SAMPLE_SUM_3.drop(['TDOP_SHD_PAY_INTS', 'REG_CAP'], axis=1) # 返回第三个时间段的数据 return train_IDV_TD_SAMPLE_SUM_3 个人活期存款账户信息（IDV_DPSA）- 处理1234567891011121314151617181920212223242526272829303132# 编成函数def IDV_DPSA_PARSE(dataset_IDV_DPSA): # 划分三张表 train_idv_dpsa_1 = dataset_IDV_DPSA[dataset_IDV_DPSA['DATA_DAT']==3728764800].reset_index() train_idv_dpsa_2 = dataset_IDV_DPSA[dataset_IDV_DPSA['DATA_DAT']==3731443200].reset_index() train_idv_dpsa_3 = dataset_IDV_DPSA[dataset_IDV_DPSA['DATA_DAT']==3734035200].reset_index() # 精简字段 train_idv_dpsa_3 = train_idv_dpsa_3.drop(['DATA_DAT', 'ARG_CRT_DAT', 'CLS_ACCT_DAT', 'MATU_DAT', 'LAC', 'ACCT_STS_CD', 'RAT_CTG', 'CUST_RANK_CD', 'DAY_TFO_SUM', 'MTH_ACT_DAYS_TOT'], axis=1) # 将IDV_DPSA表与汇率表整合 train_IDV_DPSA_SAMPLE_3 = pd.merge(train_idv_dpsa_3, train_base_excg, on = 'CCY_CD') # 去重 train_IDV_DPSA_SAMPLE_3.drop_duplicates(subset=None, keep='first', inplace=True) # 执行汇率计算函数 train_IDV_DPSA_SAMPLE_3['FRZ_TOT_AMT'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('FRZ_TOT_AMT', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['DAY_WD_ACT_AMT'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_WD_ACT_AMT', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['DAY_CSH_DP_SUM'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_CSH_DP_SUM', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['DAY_CSH_WD_SUM'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_CSH_WD_SUM', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['DAY_TFI_SUM'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_TFI_SUM', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['MOTH_CR_ACCM'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('MOTH_CR_ACCM', 'RMB_MID_PRIC')) train_IDV_DPSA_SAMPLE_3['BEG_MOTH_CRBAL'] = train_IDV_DPSA_SAMPLE_3.apply(compute_REAL_MONEY, axis = 1, args = ('BEG_MOTH_CRBAL', 'RMB_MID_PRIC')) # 再次精简表 train_IDV_DPSA_SAMPLE_3 = train_IDV_DPSA_SAMPLE_3.drop(['CCY_CD', 'RMB_MID_PRIC', 'index'], axis=1) # 避免重复字段 train_IDV_DPSA_SAMPLE_3 = train_IDV_DPSA_SAMPLE_3.rename(columns=&#123;'CRBAL':'IDV_DPSA_CRBAL', 'MOTH_CR_ACCM':'IDV_DPSA_MOTH_CR_ACCM'&#125;) # 按 CUST_NO 求和 train_IDV_DPSA_SAMPLE_3 = train_IDV_DPSA_SAMPLE_3[['CUST_NO', 'IDV_DPSA_CRBAL', 'ITST_BRNG_ACCM', 'FRZ_TOT_AMT', 'DAY_WD_ACT_AMT', 'DAY_CSH_DP_SUM', 'DAY_CSH_WD_SUM', 'DAY_TFI_SUM', 'IDV_DPSA_MOTH_CR_ACCM', 'BEG_MOTH_CRBAL']].groupby('CUST_NO').sum().reset_index() # @ 去除过分关联的特征 train_IDV_DPSA_SAMPLE_3 = train_IDV_DPSA_SAMPLE_3.drop(['BEG_MOTH_CRBAL', 'IDV_DPSA_MOTH_CR_ACCM'], axis=1) # 返回第三个时间段的数据 return train_IDV_DPSA_SAMPLE_3 交易信息（TR_DC） - 处理1234train_tr_dc_TR_TYPE = train_tr_dc.groupby(['CUST_NO','TR_TYPE'])['TR_TYPE'].count().unstack().reset_index()train_tr_dc_TR_TYPE['TR_TYPE_TIMES'] = train_tr_dc_TR_TYPE.drop('CUST_NO',axis=1).sum(axis=1)train_tr_dc_BOE = train_tr_dc_TR_TYPE[['CUST_NO','TR_TYPE_TIMES','EBMKO5RA']]train_tr_dc_BOE.columns = ['CUST_NO', 'TR_TYPE_TIMES','EBMKO5RA'] 1train_tr_dc_BOE.head() 12345678910111213141516171819202122232425262728293031323334# 声明函数def TR_DC_PARSE(dataset_TR_DC): # 去除抹帐(1),无意义列- RED_BLU_CD，这里全是0 dataset_TR_DC = dataset_TR_DC[dataset_TR_DC['CAN_IND']==0].drop(['RED_BLU_CD'],axis=1) # 将交易按照 正 / 负 分开 dataset_TR_DC['INCOME'] = dataset_TR_DC['TR_AMT'] &gt; 0 myseries = dataset_TR_DC.groupby(['CUST_NO', 'INCOME'])['TR_AMT'].sum() myseries = myseries.unstack() TR_DC_IN_OUT = pd.DataFrame(myseries).reset_index() TR_DC_IN_OUT['IN_SUM'] = TR_DC_IN_OUT[True] TR_DC_IN_OUT['OUT_SUM'] = TR_DC_IN_OUT[False] TR_DC_IN_OUT = TR_DC_IN_OUT.drop([True, False], axis=1) # 根据BOE交易代码划分 仅使用 EBMKO5RA train_tr_dc_TR_TYPE = dataset_TR_DC.groupby(['CUST_NO','TR_TYPE'])['TR_TYPE'].count().unstack().reset_index() train_tr_dc_TR_TYPE['TR_TYPE_TIMES'] = train_tr_dc_TR_TYPE.drop('CUST_NO',axis=1).sum(axis=1) train_tr_dc_BOE = train_tr_dc_TR_TYPE[['CUST_NO','TR_TYPE_TIMES','EBMKO5RA']] train_tr_dc_BOE.columns = ['CUST_NO', 'TR_TYPE_TIMES','EBMKO5RA'] # 根据SVRTO交易码划分 使用SVRTO061和SVRTO161 train_tr_dc_SVRTO061 = train_tr_dc_TR_TYPE[['CUST_NO','SVRTO061']] train_tr_dc_SVRTO161 = train_tr_dc_TR_TYPE[['CUST_NO','SVRTO161']] train_tr_dc_SVRTO061.columns = ['CUST_NO', 'SVRTO061'] train_tr_dc_SVRTO161.columns = ['CUST_NO', 'SVRTO161'] # 计算每笔交易金额的均值 TR_DC_IN_MEAN = dataset_TR_DC[dataset_TR_DC['TR_AMT']&gt;0][['CUST_NO', 'TR_AMT']].groupby('CUST_NO').mean().reset_index() TR_DC_IN_MEAN.columns = ['CUST_NO', 'TR_DC_IN_MEAN'] TR_DC_OUT_MEAN = dataset_TR_DC[dataset_TR_DC['TR_AMT']&lt;0][['CUST_NO', 'TR_AMT']].groupby('CUST_NO').mean().reset_index() TR_DC_OUT_MEAN.columns = ['CUST_NO', 'TR_DC_OUT_MEAN'] # 合并各个特征 36041 # train_TR_DC_SAMPLE = pd.merge(TR_DC_IN_OUT, train_tr_dc_BOE, on='CUST_NO', how='outer') train_TR_DC_SAMPLE = pd.merge(TR_DC_IN_OUT, TR_DC_IN_MEAN, on='CUST_NO', how='outer') train_TR_DC_SAMPLE = pd.merge(train_TR_DC_SAMPLE, TR_DC_OUT_MEAN, on='CUST_NO', how='outer') # train_TR_DC_SAMPLE = pd.merge(train_TR_DC_SAMPLE, train_tr_dc_SVRTO061, on='CUST_NO', how='outer') # train_TR_DC_SAMPLE = pd.merge(train_TR_DC_SAMPLE, train_tr_dc_SVRTO161, on='CUST_NO', how='outer') return train_TR_DC_SAMPLE 第三方存管账户信息（THR_PTY_CSTD） - 处理123456# 提前删掉无用字段train_thr_pty_cstd_temple = train_thr_pty_cstd.drop(['CCY_CD', 'CUST_CTG_CD', 'MTH_ACT_DAYS_TOT'], axis=1)# 划分三张表train_thr_pty_cstd_1 = train_thr_pty_cstd_temple[train_thr_pty_cstd_temple['DATA_DAT']==3728764800].reset_index()train_thr_pty_cstd_2 = train_thr_pty_cstd_temple[train_thr_pty_cstd_temple['DATA_DAT']==3731443200].reset_index()train_thr_pty_cstd_3 = train_thr_pty_cstd_temple[train_thr_pty_cstd_temple['DATA_DAT']==3734035200].reset_index() 12345678# 清理没用字段train_thr_pty_cstd_3 = train_thr_pty_cstd_3.drop(['index', 'DATA_DAT'], axis=1)# 对字段进行处理ARG_BAL = train_thr_pty_cstd_3.groupby(['CUST_NO'])['ARG_BAL'].sum().reset_index()AVL_BAL = train_thr_pty_cstd_3.groupby(['CUST_NO'])['AVL_BAL'].sum().reset_index()MTH_ARG_BAL_ACCM = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_ARG_BAL_ACCM'].sum().reset_index()MTH_FUD_TF_INWD_AMT = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_FUD_TF_INWD_AMT'].sum().reset_index()MTH_FUD_TF_OUT_AMT = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_FUD_TF_OUT_AMT'].sum().reset_index() 12345# 将字段合并train_thr_pty_cstd_SAMPLE = pd.merge(ARG_BAL, AVL_BAL, on='CUST_NO', how='outer')train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_ARG_BAL_ACCM, on='CUST_NO', how='outer')train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_FUD_TF_INWD_AMT, on='CUST_NO', how='outer')train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_FUD_TF_OUT_AMT, on='CUST_NO', how='outer') 12# @ 去除过分关联的特征train_thr_pty_cstd_SAMPLE = train_thr_pty_cstd_SAMPLE.drop(['ARG_BAL', 'MTH_ARG_BAL_ACCM'], axis=1) 12345678910111213141516171819202122232425# 声明函数def THR_PTY_CSTD_PARSE(dataset_THR_PTY_CSTD): # 提前删掉无用字段 dataset_THR_PTY_CSTD = dataset_THR_PTY_CSTD.drop(['CCY_CD', 'CUST_CTG_CD', 'MTH_ACT_DAYS_TOT'], axis=1) # 划分三张表 train_thr_pty_cstd_1 = dataset_THR_PTY_CSTD[dataset_THR_PTY_CSTD['DATA_DAT']==3728764800].reset_index() train_thr_pty_cstd_2 = dataset_THR_PTY_CSTD[dataset_THR_PTY_CSTD['DATA_DAT']==3731443200].reset_index() train_thr_pty_cstd_3 = dataset_THR_PTY_CSTD[dataset_THR_PTY_CSTD['DATA_DAT']==3734035200].reset_index() # 清理没用字段 train_thr_pty_cstd_3 = train_thr_pty_cstd_3.drop(['index', 'DATA_DAT'], axis=1) # 对字段进行处理 ARG_BAL = train_thr_pty_cstd_3.groupby(['CUST_NO'])['ARG_BAL'].sum().reset_index() AVL_BAL = train_thr_pty_cstd_3.groupby(['CUST_NO'])['AVL_BAL'].sum().reset_index() MTH_ARG_BAL_ACCM = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_ARG_BAL_ACCM'].sum().reset_index() MTH_FUD_TF_INWD_AMT = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_FUD_TF_INWD_AMT'].sum().reset_index() MTH_FUD_TF_OUT_AMT = train_thr_pty_cstd_3.groupby(['CUST_NO'])['MTH_FUD_TF_OUT_AMT'].sum().reset_index() # 将字段合并 train_thr_pty_cstd_SAMPLE = pd.merge(AVL_BAL, ARG_BAL, on='CUST_NO', how='outer') train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_ARG_BAL_ACCM, on='CUST_NO', how='outer') train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_FUD_TF_INWD_AMT, on='CUST_NO', how='outer') train_thr_pty_cstd_SAMPLE = pd.merge(train_thr_pty_cstd_SAMPLE, MTH_FUD_TF_OUT_AMT, on='CUST_NO', how='outer') # @ 去除过分关联的特征 train_thr_pty_cstd_SAMPLE = train_thr_pty_cstd_SAMPLE.drop(['ARG_BAL', 'MTH_ARG_BAL_ACCM'], axis=1) return train_thr_pty_cstd_SAMPLE 贷款账户信息（LOAN）- 处理123456789# 选择有用字段train_loan_temple = train_loan[['CUST_NO', 'DATA_DAT', 'ARG_TYP_CD', 'CCY_CD', 'ARG_LIF_CYC_STA_CD', 'LN_STS_CD', 'CHANL_CD', 'LN_TERM', 'RPAY_MOD_CD', 'LAC', 'NON_MATU_CAP', 'ACD_NML_INTS', 'INTS_TOT_AMT' , 'BUS_BREED_CD', 'NML_CAP_BAL', 'MTH_NML_CAP_ACCM']]train_loan_temple = pd.merge(train_loan_temple, train_base_excg, on = 'CCY_CD')# 划分三张表train_loan_1 = train_loan_temple[train_loan_temple['DATA_DAT']==3728764800]train_loan_2 = train_loan_temple[train_loan_temple['DATA_DAT']==3731443200]train_loan_3 = train_loan_temple[train_loan_temple['DATA_DAT']==3734035200]train_loan_3 = train_loan_3.drop(['DATA_DAT'], axis=1) 1train_loan_3.drop_duplicates(subset=None, keep='first', inplace=True) 123456# 执行汇率计算函数train_loan_3['ACD_NML_INTS'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('ACD_NML_INTS', 'RMB_MID_PRIC'))train_loan_3['NON_MATU_CAP'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('NON_MATU_CAP', 'RMB_MID_PRIC'))train_loan_3['NML_CAP_BAL'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('NML_CAP_BAL', 'RMB_MID_PRIC'))train_loan_3['INTS_TOT_AMT'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('INTS_TOT_AMT', 'RMB_MID_PRIC'))train_loan_3['MTH_NML_CAP_ACCM'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('MTH_NML_CAP_ACCM', 'RMB_MID_PRIC')) 123456789101112# 平均应计正常利息MEAN_ACD_NML_INTS = train_loan_3[['CUST_NO', 'ACD_NML_INTS']].groupby(['CUST_NO']).mean().reset_index()# 平均应计未到期本金MEAN_NON_MATU_CAP = train_loan_3[['CUST_NO', 'NON_MATU_CAP']].groupby(['CUST_NO']).mean().reset_index()# 平均月内正常本金基数MEAN_MTH_NML_CAP_ACCM = train_loan_3[['CUST_NO','MTH_NML_CAP_ACCM']].groupby(['CUST_NO']).mean().reset_index()# 平均贷款期限MEAN_LOAN_TERM = train_loan_3[['CUST_NO','LN_TERM']].groupby(['CUST_NO']).mean().reset_index()# 平均贷款金额MEAN_NML_CAP_BAL = train_loan_3[['CUST_NO', 'NML_CAP_BAL']].groupby(['CUST_NO']).mean().reset_index()# 平均利息总额MEAN_INTS_TOT_AMT = train_loan_3[['CUST_NO', 'INTS_TOT_AMT']].groupby(['CUST_NO']).mean().reset_index() 12train_loan_3_SAMPLE = pd.merge(pd.merge(pd.merge(pd.merge(pd.merge(MEAN_ACD_NML_INTS, MEAN_NON_MATU_CAP, on='CUST_NO', how='outer'), MEAN_MTH_NML_CAP_ACCM, on='CUST_NO', how='outer'), MEAN_LOAN_TERM, on='CUST_NO', how='outer'), MEAN_NML_CAP_BAL, on='CUST_NO', how='outer'), MEAN_INTS_TOT_AMT, on='CUST_NO', how='outer') 1234567891011121314151617181920212223242526272829303132def BY_MONTH_LOAN_METHOD(dataset_LOAN): # 选择有用字段 train_loan_temple = dataset_LOAN[['CUST_NO', 'DATA_DAT', 'ARG_TYP_CD', 'CCY_CD', 'ARG_LIF_CYC_STA_CD', 'LN_STS_CD', 'CHANL_CD', 'LN_TERM', 'RPAY_MOD_CD', 'LAC', 'NON_MATU_CAP', 'ACD_NML_INTS', 'INTS_TOT_AMT' , 'BUS_BREED_CD', 'NML_CAP_BAL', 'MTH_NML_CAP_ACCM']] train_loan_temple = pd.merge(train_loan_temple, train_base_excg, on = 'CCY_CD') # 划分三张表 train_loan_1 = train_loan_temple[train_loan_temple['DATA_DAT']==3728764800] train_loan_2 = train_loan_temple[train_loan_temple['DATA_DAT']==3731443200] train_loan_3 = train_loan_temple[train_loan_temple['DATA_DAT']==3734035200] train_loan_3 = train_loan_3.drop(['DATA_DAT'], axis=1) train_loan_3.drop_duplicates(subset=None, keep='first', inplace=True) # 执行汇率计算函数 train_loan_3['ACD_NML_INTS'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('ACD_NML_INTS', 'RMB_MID_PRIC')) train_loan_3['NON_MATU_CAP'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('NON_MATU_CAP', 'RMB_MID_PRIC')) train_loan_3['NML_CAP_BAL'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('NML_CAP_BAL', 'RMB_MID_PRIC')) train_loan_3['INTS_TOT_AMT'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('INTS_TOT_AMT', 'RMB_MID_PRIC')) train_loan_3['MTH_NML_CAP_ACCM'] = train_loan_3.apply(compute_REAL_MONEY, axis = 1, args = ('MTH_NML_CAP_ACCM', 'RMB_MID_PRIC')) # 平均应计正常利息 MEAN_ACD_NML_INTS = train_loan_3[['CUST_NO', 'ACD_NML_INTS']].groupby(['CUST_NO']).mean().reset_index() # 平均应计未到期本金 MEAN_NON_MATU_CAP = train_loan_3[['CUST_NO', 'NON_MATU_CAP']].groupby(['CUST_NO']).mean().reset_index() # 平均月内正常本金基数 MEAN_MTH_NML_CAP_ACCM = train_loan_3[['CUST_NO','MTH_NML_CAP_ACCM']].groupby(['CUST_NO']).mean().reset_index() # 平均贷款期限 MEAN_LOAN_TERM = train_loan_3[['CUST_NO','LN_TERM']].groupby(['CUST_NO']).mean().reset_index() # 平均贷款金额 MEAN_NML_CAP_BAL = train_loan_3[['CUST_NO', 'NML_CAP_BAL']].groupby(['CUST_NO']).mean().reset_index() # 平均利息总额 MEAN_INTS_TOT_AMT = train_loan_3[['CUST_NO', 'INTS_TOT_AMT']].groupby(['CUST_NO']).mean().reset_index() train_loan_3_SAMPLE = pd.merge(pd.merge(pd.merge(pd.merge(pd.merge(MEAN_ACD_NML_INTS, MEAN_NON_MATU_CAP, on='CUST_NO', how='outer'), MEAN_MTH_NML_CAP_ACCM, on='CUST_NO', how='outer'), MEAN_LOAN_TERM, on='CUST_NO', how='outer'), MEAN_NML_CAP_BAL, on='CUST_NO', how='outer'), MEAN_INTS_TOT_AMT, on='CUST_NO', how='outer') return train_loan_3_SAMPLE 基金账户信息（FUND）- 处理123456789101112131415161718192021222324252627282930313233343536373839def BY_MONTH_FUND_METHOD(dataset_FOUND): # 预处理 train_fund_temple = dataset_FOUND.drop(['CCY_CD', 'ARG_CRT_DAT', 'ARG_LIF_CYC_STA_CD', 'CHANL_CD', 'VLU_DAT', 'DATE_MATU', 'CLS_ACCT_DAT', 'LAST_ACT_CHNG_DAT', 'MTH_ACT_DAYS_TOT'], axis=1) # 按月将金额分组 BY_MONTH_FUND_TABLE = train_fund_temple.groupby(['CUST_NO', 'DATA_DAT'])[['FUD_UNIT_NET_VAL', 'FUD_PROD_TYP_CD', 'RSK_RANK_CD', 'SHR', 'MOTH_BAL_ACCM', 'FUND_BAL', 'FUND_BAL_MOTH_BAL_ACCM']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_FUND(key): train_fund_temple_STD = BY_MONTH_FUND_TABLE[key].std(axis=1).reset_index() train_fund_temple_STD.columns = ['CUST_NO', str('FUND_'+key+'_STD')] train_fund_temple_MEAN = BY_MONTH_FUND_TABLE[key].mean(axis=1).reset_index() train_fund_temple_MEAN.columns = ['CUST_NO',str('FUND_'+key+'_MEAN')] train_fund_temple_MAX = BY_MONTH_FUND_TABLE[key].max(axis=1).reset_index() train_fund_temple_MAX.columns = ['CUST_NO',str('FUND_'+key+'_MAX')] train_fund_temple_MIN = BY_MONTH_FUND_TABLE[key].min(axis=1).reset_index() train_fund_temple_MIN.columns = ['CUST_NO',str('FUND_'+key+'_MIN')] # 合并字段 train_fund_temple = pd.merge(train_fund_temple_STD, train_fund_temple_MEAN, on='CUST_NO', how='inner') train_fund_temple = pd.merge(train_fund_temple, train_fund_temple_MAX, on='CUST_NO', how='inner') train_fund_temple = pd.merge(train_fund_temple, train_fund_temple_MIN, on='CUST_NO', how='inner') return train_fund_temple train_fund_temple = BY_MONTH_FUND('RSK_RANK_CD') for key in ['FUD_UNIT_NET_VAL', 'FUD_PROD_TYP_CD', 'SHR', 'MOTH_BAL_ACCM', 'FUND_BAL', 'FUND_BAL_MOTH_BAL_ACCM']: train_fund_temple = pd.merge(train_fund_temple, BY_MONTH_FUND(key)) train_fund_temple.drop_duplicates(subset=None, keep='first', inplace=True) # 定申定赎 开通标识 SUM_FUND_RATN_APLY_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_APLY_OPN_IND']].groupby(['CUST_NO']).sum().reset_index() STD_FUND_RATN_APLY_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_APLY_OPN_IND']].groupby(['CUST_NO']).std().reset_index() MEAN_FUND_RATN_APLY_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_APLY_OPN_IND']].groupby(['CUST_NO']).mean().reset_index() MAX_FUND_RATN_APLY_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_APLY_OPN_IND']].groupby(['CUST_NO']).max().reset_index() MIN_FUND_RATN_APLY_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_APLY_OPN_IND']].groupby(['CUST_NO']).min().reset_index() SUM_FUND_RATN_REDM_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_REDM_OPN_IND']].groupby(['CUST_NO']).sum().reset_index() STD_FUND_RATN_REDM_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_REDM_OPN_IND']].groupby(['CUST_NO']).std().reset_index() MEAN_FUND_RATN_REDM_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_REDM_OPN_IND']].groupby(['CUST_NO']).mean().reset_index() MAX_FUND_RATN_REDM_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_REDM_OPN_IND']].groupby(['CUST_NO']).max().reset_index() MIN_FUND_RATN_REDM_OPN_IND = dataset_FOUND[['CUST_NO', 'RATN_REDM_OPN_IND']].groupby(['CUST_NO']).min().reset_index() train_fund_temple = pd.merge(pd.merge(train_fund_temple, STD_FUND_RATN_APLY_OPN_IND, on='CUST_NO', how='outer'), MIN_FUND_RATN_REDM_OPN_IND, on='CUST_NO', how='outer') return train_fund_temple 国债账户信息（BOND）- 处理1234567891011121314151617181920212223242526def BY_MONTH_BOND_METHOD(dataset_BOND): # 预处理 train_bond_temple = dataset_BOND.drop(['CCY_CD', 'ARG_CRT_DAT', 'MATU_DAT', 'MATU_DAT', 'PROD_CLS_CD', 'CERT_DAT', 'CLS_ACCT_DAT', 'ARG_LIF_CYC_STA_CD', 'NTNL_DEBT_INTS_TYP_CD', 'MTH_ACT_DAYS_TOT'], axis=1) # 按月将金额分组 BY_MONTH_BOND_TABLE = train_bond_temple.groupby(['CUST_NO', 'DATA_DAT'])[['BOND_TERM_CD', 'ARG_CUR_BAL', 'HOD_SHR', 'UNIT_NET_VAL', 'NVTA_MOTH_ACCM']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_BOND(key): train_bond_temple_STD = BY_MONTH_BOND_TABLE[key].std(axis=1).reset_index() train_bond_temple_STD.columns = ['CUST_NO', str('BOND_'+key+'_STD')] train_bond_temple_MEAN = BY_MONTH_BOND_TABLE[key].mean(axis=1).reset_index() train_bond_temple_MEAN.columns = ['CUST_NO',str('BOND_'+key+'_MEAN')] train_bond_temple_MAX = BY_MONTH_BOND_TABLE[key].max(axis=1).reset_index() train_bond_temple_MAX.columns = ['CUST_NO',str('BOND_'+key+'_MAX')] train_bond_temple_MIN = BY_MONTH_BOND_TABLE[key].min(axis=1).reset_index() train_bond_temple_MIN.columns = ['CUST_NO',str('BOND_'+key+'_MIN')] # 合并字段 train_bond_temple = pd.merge(train_bond_temple_STD, train_bond_temple_MEAN, on='CUST_NO', how='inner') train_bond_temple = pd.merge(train_bond_temple, train_bond_temple_MAX, on='CUST_NO', how='inner') train_bond_temple = pd.merge(train_bond_temple, train_bond_temple_MIN, on='CUST_NO', how='inner') return train_bond_temple train_bond_temple = BY_MONTH_BOND('BOND_TERM_CD') for key in ['ARG_CUR_BAL', 'HOD_SHR', 'UNIT_NET_VAL', 'NVTA_MOTH_ACCM']: train_bond_temple = pd.merge(train_bond_temple, BY_MONTH_BOND(key)) train_bond_temple.drop_duplicates(subset=None, keep='first', inplace=True) return train_bond_temple 贵金属账户信息（PREC_METAL）- 处理12345678910111213141516171819202122232425262728293031def BY_MONTH_PREC_METAL_METHOD(dataset_PREC_METAL): # 预处理 train_prec_metal_temple = dataset_PREC_METAL.drop(['PREC_METAL_BREED_CD', 'ARG_STS_CD', 'SIGD_DAT', 'SIGD_CHANL_CD', 'TEMN_DAT', 'TEMN_CHANL_CD', 'MTH_ACT_DAYS_TOT'], axis=1) # 将train_prec_metal和train_base_excg合并 train_prec_metal_temple = pd.merge(train_prec_metal_temple, train_base_excg, on = 'CCY_CD') # 执行汇率计算函数 train_prec_metal_temple['ARG_BAL'] = train_prec_metal_temple.apply(compute_REAL_MONEY, axis = 1, args = ('ARG_BAL', 'RMB_MID_PRIC')) # 按月将金额分组 BY_MONTH_PREC_METAL_TABLE = train_prec_metal_temple.groupby(['CUST_NO', 'DATA_DAT'])[['BUS_CTG_CD', 'CNT', 'ARG_BAL', 'MTH_ARG_ACCM']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_PREC_METAL(key): train_prec_metal_temple_STD = BY_MONTH_PREC_METAL_TABLE[key].std(axis=1).reset_index() train_prec_metal_temple_STD.columns = ['CUST_NO', str('PREC_METAL_'+key+'_STD')] train_prec_metal_temple_MEAN = BY_MONTH_PREC_METAL_TABLE[key].mean(axis=1).reset_index() train_prec_metal_temple_MEAN.columns = ['CUST_NO',str('PREC_METAL_'+key+'_MEAN')] train_prec_metal_temple_MAX = BY_MONTH_PREC_METAL_TABLE[key].max(axis=1).reset_index() train_prec_metal_temple_MAX.columns = ['CUST_NO',str('PREC_METAL_'+key+'_MAX')] train_prec_metal_temple_MIN = BY_MONTH_PREC_METAL_TABLE[key].min(axis=1).reset_index() train_prec_metal_temple_MIN.columns = ['CUST_NO',str('PREC_METAL_'+key+'_MIN')] # 合并字段 train_prec_metal_temple = pd.merge(train_prec_metal_temple_STD, train_prec_metal_temple_MEAN, on='CUST_NO', how='inner') train_prec_metal_temple = pd.merge(train_prec_metal_temple, train_prec_metal_temple_MAX, on='CUST_NO', how='inner') train_prec_metal_temple = pd.merge(train_prec_metal_temple, train_prec_metal_temple_MIN, on='CUST_NO', how='inner') return train_prec_metal_temple train_prec_metal_temple = BY_MONTH_PREC_METAL('BUS_CTG_CD') for key in ['CNT', 'ARG_BAL', 'MTH_ARG_ACCM']: train_prec_metal_temple = pd.merge(train_prec_metal_temple, BY_MONTH_PREC_METAL(key)) train_prec_metal_temple.drop_duplicates(subset=None, keep='first', inplace=True) return train_prec_metal_temple 代理保险账户信息（AGET_INSR）- 处理1234567891011121314151617181920212223242526def BY_MONTH_AGET_INSR_METHOD(dataset_AGET_INSR): # 预处理 train_aget_insr_temple = dataset_AGET_INSR[['DATA_DAT', 'CUST_NO', 'PREM', 'CVAG', 'INSE_CNT', 'MTH_PREM_ACCM', 'BEG_MTH_PREM_BAL']] # 按月将金额分组 BY_MONTH_AGET_INSR_TABLE = train_aget_insr_temple.groupby(['CUST_NO', 'DATA_DAT'])[['PREM', 'CVAG', 'INSE_CNT', 'MTH_PREM_ACCM', 'BEG_MTH_PREM_BAL']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_AGET_INSR(key): train_aget_insr_temple_STD = BY_MONTH_AGET_INSR_TABLE[key].std(axis=1).reset_index() train_aget_insr_temple_STD.columns = ['CUST_NO', str('AGET_INSR_'+key+'_STD')] train_aget_insr_temple_MEAN = BY_MONTH_AGET_INSR_TABLE[key].mean(axis=1).reset_index() train_aget_insr_temple_MEAN.columns = ['CUST_NO',str('AGET_INSR_'+key+'_MEAN')] train_aget_insr_temple_MAX = BY_MONTH_AGET_INSR_TABLE[key].max(axis=1).reset_index() train_aget_insr_temple_MAX.columns = ['CUST_NO',str('AGET_INSR_'+key+'_MAX')] train_aget_insr_temple_MIN = BY_MONTH_AGET_INSR_TABLE[key].min(axis=1).reset_index() train_aget_insr_temple_MIN.columns = ['CUST_NO',str('AGET_INSR_'+key+'_MIN')] # 合并字段 train_aget_insr_temple = pd.merge(train_aget_insr_temple_STD, train_aget_insr_temple_MEAN, on='CUST_NO', how='inner') train_aget_insr_temple = pd.merge(train_aget_insr_temple, train_aget_insr_temple_MAX, on='CUST_NO', how='inner') train_aget_insr_temple = pd.merge(train_aget_insr_temple, train_aget_insr_temple_MIN, on='CUST_NO', how='inner') return train_aget_insr_temple train_aget_insr_temple = BY_MONTH_AGET_INSR('PREM') for key in ['CVAG', 'INSE_CNT', 'MTH_PREM_ACCM', 'BEG_MTH_PREM_BAL']: train_aget_insr_temple = pd.merge(train_aget_insr_temple, BY_MONTH_AGET_INSR(key)) train_aget_insr_temple.drop_duplicates(subset=None, keep='first', inplace=True) return train_aget_insr_temple 表间融合TRAIN集123456789101112131415# train 集 38256dataset_train = pd.merge(IDV_CUST_BASIC_PARSE(CALC_AGE(train_idv_cust_basic)), IDV_TD_PARSE(train_idv_td), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, IDV_DPSA_PARSE(train_idv_dpsa), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, TR_DC_PARSE(train_tr_dc), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_IDV_TD_METHOD(train_idv_td), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_IDV_DPSA_METHOD(train_idv_dpsa), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_TR_DC_METHOD(train_tr_dc), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, THR_PTY_CSTD_PARSE(train_thr_pty_cstd), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_LOAN_METHOD(train_loan), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_FUND_METHOD(train_fund), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_BOND_METHOD(train_bond), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_PREC_METAL_METHOD(train_prec_metal), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, BY_MONTH_AGET_INSR_METHOD(train_aget_insr), on='CUST_NO', how='outer')dataset_train = pd.merge(dataset_train, AUM_NUMS(train_idv_td, train_bond, train_fund, train_prec_metal, train_aget_insr, train_idv_cust_basic), on='CUST_NO', how='outer')dataset_train = pd.merge(WEALTH(train_cust_result,train_idv_td,train_bond,train_fund,train_prec_metal,train_aget_insr,train_thr_pty_cstd), dataset_train, on='CUST_NO', how='outer') /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:20: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:26: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/pandas/core/reshape/merge.py:558: UserWarning: merging between different levels can give an unintended result (1 levels on the left, 2 on the right) warnings.warn(msg, UserWarning) /root/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py:2530: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance. obj = obj._drop_axis(labels, axis, level=level, errors=errors)12# 将个人客户基本信息表与结果整合dataset_train = pd.merge(dataset_train, train_cust_result, on='CUST_NO') TRAIN 剪枝12# 删除无用字段dataset_train = dataset_train.drop(['CUST_NO'], axis=1) A集123456789101112131415# A 集 4782dataset_A = pd.merge(IDV_CUST_BASIC_PARSE(CALC_AGE(A_idv_cust_basic)), IDV_TD_PARSE(A_idv_td), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, IDV_DPSA_PARSE(A_idv_dpsa), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, TR_DC_PARSE(A_tr_dc), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_IDV_TD_METHOD(A_idv_td), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_IDV_DPSA_METHOD(A_idv_dpsa), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_TR_DC_METHOD(A_tr_dc), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, THR_PTY_CSTD_PARSE(A_thr_pty_cstd), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_LOAN_METHOD(A_loan), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_FUND_METHOD(A_fund), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_BOND_METHOD(A_bond), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_PREC_METAL_METHOD(A_prec_metal), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, BY_MONTH_AGET_INSR_METHOD(A_aget_insr), on='CUST_NO', how='outer')dataset_A = pd.merge(dataset_A, AUM_NUMS(A_idv_td, A_bond, A_fund, A_prec_metal, A_aget_insr, A_idv_cust_basic), on='CUST_NO', how='outer')dataset_A = pd.merge(WEALTH(A_customid,A_idv_td,A_bond,A_fund,A_prec_metal,A_aget_insr,A_thr_pty_cstd), dataset_A, on='CUST_NO', how='outer') /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:20: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:26: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/pandas/core/reshape/merge.py:558: UserWarning: merging between different levels can give an unintended result (1 levels on the left, 2 on the right) warnings.warn(msg, UserWarning) /root/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py:2530: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance. obj = obj._drop_axis(labels, axis, level=level, errors=errors)A 剪枝12# 删除无用字段dataset_A = dataset_A.drop(['CUST_NO'], axis=1) B集123456789101112131415# A 集 4782dataset_B = pd.merge(IDV_CUST_BASIC_PARSE(CALC_AGE(B_idv_cust_basic)), IDV_TD_PARSE(B_idv_td), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, IDV_DPSA_PARSE(B_idv_dpsa), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, TR_DC_PARSE(B_tr_dc), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_IDV_TD_METHOD(B_idv_td), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_IDV_DPSA_METHOD(B_idv_dpsa), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_TR_DC_METHOD(B_tr_dc), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, THR_PTY_CSTD_PARSE(B_thr_pty_cstd), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_LOAN_METHOD(B_loan), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_FUND_METHOD(B_fund), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_BOND_METHOD(B_bond), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_PREC_METAL_METHOD(B_prec_metal), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, BY_MONTH_AGET_INSR_METHOD(B_aget_insr), on='CUST_NO', how='outer')dataset_B = pd.merge(dataset_B, AUM_NUMS(B_idv_td, B_bond, B_fund, B_prec_metal, B_aget_insr, B_idv_cust_basic), on='CUST_NO', how='outer')dataset_B = pd.merge(WEALTH(B_customid,B_idv_td,B_bond,B_fund,B_prec_metal,B_aget_insr,B_thr_pty_cstd), dataset_B, on='CUST_NO', how='outer') /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:20: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:26: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy /root/anaconda3/lib/python3.6/site-packages/pandas/core/reshape/merge.py:558: UserWarning: merging between different levels can give an unintended result (1 levels on the left, 2 on the right) warnings.warn(msg, UserWarning) /root/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py:2530: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance. obj = obj._drop_axis(labels, axis, level=level, errors=errors)B集剪枝12# 删除无用字段dataset_B = dataset_B.drop(['CUST_NO'], axis=1) 欠采样1train_SAMPLE = pd.concat([dataset_train[dataset_train['FLAG']==0].sample(frac=0.20),dataset_train[dataset_train['FLAG']==1]],axis=0).sample(frac=1.0) 算法分析12345678910111213141516171819202122232425262728293031import numpy as np import pandas as pd import xgboost as xgb import time from sklearn.model_selection import StratifiedKFold from sklearn.model_selection import train_test_splitfrom imblearn.over_sampling import SMOTEfrom sklearn.model_selection import GridSearchCV# 构建特征 #X = dataset_train.drop(['FLAG'],axis=1).fillna(0)#y = dataset_train['FLAG']X = train_SAMPLE.drop(['FLAG'],axis=1).fillna(0)y = train_SAMPLE['FLAG']# X = dataset_train_SAMPLE.drop(['FLAG'],axis=1)# y = dataset_train_SAMPLE['FLAG'] # 用sklearn.cross_validation进行训练数据集划分X, val_X, y, val_y = train_test_split( X, y, test_size=0.01, #test_size=0.125, random_state=2020, )# SMOTE过采样# smo = SMOTE(random_state=2019)# X_smo, y_smo = smo.fit_sample(X, y)# X_smo = pd.DataFrame(X_smo)# X_smo.columns=['XXX'] 123456789101112131415161718192021222324import numpy as np import pandas as pd import xgboost as xgb import time from sklearn.model_selection import StratifiedKFold from sklearn.model_selection import train_test_splitfrom imblearn.over_sampling import SMOTEfrom sklearn.model_selection import GridSearchCV# 构建特征 X = dataset_train.drop(['FLAG'],axis=1).fillna(0)y = dataset_train['FLAG'] # 用sklearn.cross_validation进行训练数据集划分X, val_X, y, val_y = train_test_split( X, y, test_size=0.125, random_state=2019, )train_REAL = pd.concat([X,y],axis=1)train_REAL = pd.concat([train_REAL[train_REAL['FLAG']==0].sample(frac=0.20),train_REAL[train_REAL['FLAG']==1]],axis=0).sample(frac=1.0)X = train_REAL.drop(['FLAG'],axis=1)y = train_REAL['FLAG'] XGB算法12345678910111213141516171819202122232425262728293031323334353637383940414243# xgb矩阵赋值 xgb_val = xgb.DMatrix(val_X, label=val_y) # xgb_train = xgb.DMatrix(X_smo, label=y_smo)xgb_train = xgb.DMatrix(X, label=y) # xgboost模型#params = &#123; 'booster': 'gbtree', # 'objective': 'multi:softmax', # 多分类的问题、 # 'objective': 'multi:softprob', # 多分类概率 'objective': 'binary:logistic', 'eval_metric': 'logloss', # 'num_class': 9, # 类别数，与 multisoftmax 并用 'gamma': 0.1, # 用于控制是否后剪枝的参数,越大越保守，一般0.1、0.2这样子。 'max_depth': 5, # 构建树的深度，越大越容易过拟合 'alpha': 0, # L1正则化系数 'lambda': 8, # 控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。 'subsample': 1, # 随机采样训练样本 'colsample_bytree': 0.6, # 生成树时进行的列采样 'min_child_weight': 3, # 这个参数默认是 1，是每个叶子里面 h 的和至少是多少，对正负样本不均衡时的 0-1 分类而言 # ，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本。 # 这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。 'silent': 0, # 设置成1则没有运行信息输出，最好是设置为0. 'eta': 0.01 , #'eta': 0.1, # 如同学习率 - result 0.554455 'seed': 1000, 'nthread': 24, # cpu 线程数 'missing': 1, 'scale_pos_weight': (np.sum(y==0)/np.sum(y==1)) # 用来处理正负样本不均衡的问题,通常取：sum(negative cases) / sum(positive cases) # 'eval_metric': 'auc' &#125;plst = list(params.items()) num_rounds = 30000 # 迭代次数 watchlist = [(xgb_train, 'train'), (xgb_val, 'val')] # 交叉验证 result = xgb.cv(plst, xgb_train, num_boost_round=200, nfold=4, early_stopping_rounds=200, verbose_eval=True, folds=StratifiedKFold(n_splits=4).split(X, y)) # 训练模型并保存 # early_stopping_rounds 当设置的迭代次数较大时，early_stopping_rounds 可在一定的迭代次数内准确率没有提升就停止训练 model = xgb.train(plst, xgb_train, num_rounds, watchlist, early_stopping_rounds=400) 12# 模型保存model.save_model('./leezy_xgb.model') # 用于存储训练出的模型 12345678910111213# 读取模型# model = xgb.Booster(model_file='5903-xgb.model')# 本地验证xgb_test = xgb.DMatrix(val_X) preds = model.predict(xgb_test)# 导出结果 threshold = 0.70ans = []for pred in preds: result = 1 if pred &gt; threshold else 0 ans.append(result)pred_result= pd.Series(ans, dtype='int32')evaluate(val_y, pred_result) test_pct_1: 0.1581 pred_pct_1: 0.1836 Precesion: 0.5581 Recall: 0.6481 F1-score: 0.5998 confusion matrix: [[3638 388] [ 266 490]] {&apos;Confusuion&apos;: array([[3638, 388], [ 266, 490]]), &apos;F1&apos;: 0.5997552019583843, &apos;Precision&apos;: 0.5580865603644647, &apos;acc&apos;: 0.863237139272271, &apos;pred_pct_1&apos;: 0.1836051861145964, &apos;recall&apos;: 0.6481481481481481, &apos;roc_auc&apos;: 0.7758872881823701, &apos;test_pct_1&apos;: 0.15809284818067754}1234567891011# A集训练xgb_A = xgb.DMatrix(dataset_A)A_preds = model.predict(xgb_A) # 导出结果 threshold = 0.40ans = []for pred in A_preds: result = 1 if pred &gt; threshold else 0 ans.append(result)pred_A_result= pd.Series(ans, dtype='int32') 1234567891011# B集训练xgb_B = xgb.DMatrix(dataset_B)B_preds = model.predict(xgb_B) # 导出结果 threshold = 0.68ans = []for pred in B_preds: result = 1 if pred &gt; threshold else 0 ans.append(result)pred_B_result= pd.Series(ans, dtype='int32') 1234import operatorimportance = model.get_fscore()importance = sorted(importance.items(), key=operator.itemgetter(1))# print(importance) 1234import matplotlib.pyplot as pltplt.rcParams["figure.figsize"]=(30,40)xgb.plot_importance(model, max_num_features=100)plt.show() /root/anaconda3/lib/python3.6/site-packages/matplotlib/font_manager.py:1320: UserWarning: findfont: Font family [&apos;sans-serif&apos;] not found. Falling back to DejaVu Sans (prop.get_family(), self.defaultFamily[fontext])) 12# 查看特征排名feature_rank(model, 30) 提交结果1pred_B_result.value_counts() 0 3901 1 881 dtype: int6412# 合并结果result = pd.concat([B_customid, pred_B_result],axis=1) 1result.to_csv('111.csv',header=0,index=0) 1init_woody The prv extension is already loaded. To reload it, use: %reload_ext prv Matplotlib env init complete. Warnings off.1predict 2 000.csv &apos;提交次数已用完，请明日再试！&apos;深化特征工程各类理财产品的持有数量123456train_idv_td = pd.read_csv("../data/2/train/IDV_TD.csv", encoding='utf-8') # 个人定期存款账户信息（IDV_TD）train_bond = pd.read_csv("../data/2/train/BOND.csv", encoding='utf-8') # 国债账户信息（BOND）train_fund = pd.read_csv("../data/2/train/FUND.csv", encoding='utf-8') # 基金账户信息（FUND）train_prec_metal = pd.read_csv("../data/2/train/PREC_METAL.csv", encoding='utf-8') # 贵金属账户信息（PREC_METAL）train_aget_insr = pd.read_csv("../data/2/train/AGET_INSR.csv", encoding='utf-8') # 代理保险账户信息（AGET_INSR）train_idv_cust_basic = pd.read_csv("../data/2/train/IDV_CUST_BASIC.csv", encoding='utf-8') # 个人客户基本信息（IDV_CUST_BASIC） /root/anaconda3/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2728: DtypeWarning: Columns (12) have mixed types. Specify dtype option on import or set low_memory=False. interactivity=interactivity, compiler=compiler, result=result)12345# 定期的个数train_idv_td_3 = train_idv_td[train_idv_td['DATA_DAT']==3734035200]train_idv_td_AUM = train_idv_td_3[['CUST_NO', 'ARG_CRT_DAT']]train_idv_td_num = train_idv_td_AUM.groupby('CUST_NO').count().reset_index()train_idv_td_num.rename(columns=&#123;'ARG_CRT_DAT':'IDV_TD_NUM'&#125;, inplace=True) 12345# 国债的个数train_bond_3 = train_bond[train_bond['DATA_DAT']==3734035200]train_bond_AUM = train_bond_3[['CUST_NO', 'ARG_CRT_DAT']]train_bond_num = train_bond_AUM.groupby('CUST_NO').count().reset_index()train_bond_num.rename(columns=&#123;'ARG_CRT_DAT':'BOND_NUM'&#125;, inplace=True) 12345# 基金的个数train_fund_3 = train_fund[train_fund['DATA_DAT']==3734035200]train_fund_AUM = train_fund[['CUST_NO', 'ARG_CRT_DAT']]train_fund_num = train_fund_AUM.groupby('CUST_NO').count().reset_index()train_fund_num.rename(columns=&#123;'ARG_CRT_DAT':'FUND_NUM'&#125;, inplace=True) 123456# 贵金属的个数train_prec_metal_3 = train_prec_metal[train_prec_metal['DATA_DAT']==3734035200]train_prec_metal_3.dropna(subset=['SIGD_DAT'], inplace=True)train_prec_metal_AUM = train_prec_metal_3[['CUST_NO', 'SIGD_DAT']]train_prec_metal_num = train_prec_metal_AUM.groupby('CUST_NO').count().reset_index()train_prec_metal_num.rename(columns=&#123;'SIGD_DAT':'PREC_METAL_NUM'&#125;, inplace=True) /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:3: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy This is separate from the ipykernel package so we can avoid doing imports until123456# 保险的个数train_aget_insr_3 = train_aget_insr[train_aget_insr['DATA_DAT']==3734035200]train_aget_insr_3.dropna(subset=['INSE_DAT'], inplace=True)train_aget_insr_AUM = train_aget_insr_3[['CUST_NO', 'INSE_DAT']]train_aget_insr_num = train_aget_insr_AUM.groupby('CUST_NO').count().reset_index()train_aget_insr_num.rename(columns=&#123;'INSE_DAT':'AGET_INSR_NUM'&#125;, inplace=True) /root/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:3: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy This is separate from the ipykernel package so we can avoid doing imports until12# 客户IDCUST_NO_LSIT = train_idv_cust_basic['CUST_NO'].reset_index().drop('index', axis=1) 123# 合并为一个表CUST_NO_AUM_LSIT = pd.merge(pd.merge(pd.merge(pd.merge(pd.merge(CUST_NO_LSIT, train_idv_td_num, on='CUST_NO', how='outer'), train_bond_num, on='CUST_NO', how='outer'), train_fund_num, on='CUST_NO', how='outer'), train_prec_metal_num, on='CUST_NO', how='outer'), train_aget_insr_num, on='CUST_NO', how='outer').fillna(0) 1CUST_NO_AUM_LSIT['PRODUCTS_NUM'] = CUST_NO_AUM_LSIT[['IDV_TD_NUM','BOND_NUM','FUND_NUM','PREC_METAL_NUM','AGET_INSR_NUM']].sum(axis=1) 1CUST_NO_AUM_LSIT[CUST_NO_AUM_LSIT['CUST_NO'] == 'a100d07faf0bc3c60d7d65abd704142a'] 1CUST_NO_AUM_LSIT.head(100) 1MyAUMTest = pd.merge(CUST_NO_AUM_LSIT, train_cust_result, on='CUST_NO', how='outer') 1MyAUMTest.head(10) 1CUST_NO_AUM_LSIT.shape (38256, 6)12# 关联关系g = sns.heatmap(MyAUMTest[['FLAG', 'IDV_TD_NUM','BOND_NUM','FUND_NUM','PREC_METAL_NUM','AGET_INSR_NUM','PRODUCTS_NUM']].corr(), annot=True, cmap="coolwarm") /root/anaconda3/lib/python3.6/site-packages/matplotlib/font_manager.py:1320: UserWarning: findfont: Font family [&apos;sans-serif&apos;] not found. Falling back to DejaVu Sans (prop.get_family(), self.defaultFamily[fontext])) 12345678910111213141516171819202122232425262728293031323334353637# 获取到所有投资种类的和def AUM_NUMS(train_idv_td, train_bond, train_fund, train_prec_metal, train_aget_insr, train_idv_cust_basic): # 定期的个数 train_idv_td_3 = train_idv_td[train_idv_td['DATA_DAT']==3734035200] train_idv_td_AUM = train_idv_td_3[['CUST_NO', 'ARG_CRT_DAT']] train_idv_td_num = train_idv_td_AUM.groupby('CUST_NO').count().reset_index() train_idv_td_num.rename(columns=&#123;'ARG_CRT_DAT':'IDV_TD_NUM'&#125;, inplace=True) # 国债的个数 train_bond_3 = train_bond[train_bond['DATA_DAT']==3734035200] train_bond_AUM = train_bond_3[['CUST_NO', 'ARG_CRT_DAT']] train_bond_num = train_bond_AUM.groupby('CUST_NO').count().reset_index() train_bond_num.rename(columns=&#123;'ARG_CRT_DAT':'BOND_NUM'&#125;, inplace=True) # 基金的个数 train_fund_3 = train_fund[train_fund['DATA_DAT']==3734035200] train_fund_AUM = train_fund[['CUST_NO', 'ARG_CRT_DAT']] train_fund_num = train_fund_AUM.groupby('CUST_NO').count().reset_index() train_fund_num.rename(columns=&#123;'ARG_CRT_DAT':'FUND_NUM'&#125;, inplace=True) # 贵金属的个数 train_prec_metal_3 = train_prec_metal[train_prec_metal['DATA_DAT']==3734035200] train_prec_metal_3.dropna(subset=['SIGD_DAT'], inplace=True) train_prec_metal_AUM = train_prec_metal_3[['CUST_NO', 'SIGD_DAT']] train_prec_metal_num = train_prec_metal_AUM.groupby('CUST_NO').count().reset_index() train_prec_metal_num.rename(columns=&#123;'SIGD_DAT':'PREC_METAL_NUM'&#125;, inplace=True) # 保险的个数 train_aget_insr_3 = train_aget_insr[train_aget_insr['DATA_DAT']==3734035200] train_aget_insr_3.dropna(subset=['INSE_DAT'], inplace=True) train_aget_insr_AUM = train_aget_insr_3[['CUST_NO', 'INSE_DAT']] train_aget_insr_num = train_aget_insr_AUM.groupby('CUST_NO').count().reset_index() train_aget_insr_num.rename(columns=&#123;'INSE_DAT':'AGET_INSR_NUM'&#125;, inplace=True) # 客户ID CUST_NO_LSIT = train_idv_cust_basic['CUST_NO'].reset_index().drop('index', axis=1) # 合并为一个表 CUST_NO_AUM_LSIT = pd.merge(pd.merge(pd.merge(pd.merge(pd.merge(CUST_NO_LSIT, train_idv_td_num, on='CUST_NO', how='outer'), train_bond_num, on='CUST_NO', how='outer'), train_fund_num, on='CUST_NO', how='outer'), train_prec_metal_num, on='CUST_NO', how='outer'), train_aget_insr_num, on='CUST_NO', how='outer').fillna(0) CUST_NO_AUM_LSIT['PRODUCTS_NUM'] = CUST_NO_AUM_LSIT[['IDV_TD_NUM','BOND_NUM','FUND_NUM','PREC_METAL_NUM','AGET_INSR_NUM']].sum(axis=1) return CUST_NO_AUM_LSIT 三个月变动定期账户12345678910111213141516171819202122232425262728293031323334353637def BY_MONTH_IDV_TD_METHOD(dataset_IDV_TD): # 预处理 # 简化IDV_TD表 train_idv_td_temple = dataset_IDV_TD.drop(['ARG_CRT_DAT', 'CLS_ACCT_DAT', 'MATU_DAT', 'LAC', 'ACCT_STS_CD','DP_DAY_CD', 'RDEP_IND_CD', 'RDEP_DP_DAY_CD', 'RAT_CTG','FXDI_SA_ACCM', 'MTH_ACT_DAYS_TOT'], axis=1) # 将train_idv_td和train_base_excg合并 train_idv_td_temple = pd.merge(train_idv_td_temple, train_base_excg, on = 'CCY_CD') # 执行汇率计算函数 train_idv_td_temple['CRBAL'] = train_idv_td_temple.apply(compute_REAL_MONEY, axis = 1, args = ('CRBAL', 'RMB_MID_PRIC')) train_idv_td_temple['REG_CAP'] = train_idv_td_temple.apply(compute_REAL_MONEY, axis = 1, args = ('REG_CAP', 'RMB_MID_PRIC')) train_idv_td_temple['FXDI_T_ACCM'] = train_idv_td_temple.apply(compute_REAL_MONEY, axis = 1, args = ('FXDI_T_ACCM', 'RMB_MID_PRIC')) train_idv_td_temple['TDOP_SHD_PAY_INTS'] = train_idv_td_temple.apply(compute_REAL_MONEY, axis = 1, args = ('TDOP_SHD_PAY_INTS', 'RMB_MID_PRIC')) train_idv_td_temple['MOTH_CR_ACCM'] = train_idv_td_temple.apply(compute_REAL_MONEY, axis = 1, args = ('MOTH_CR_ACCM', 'RMB_MID_PRIC')) train_idv_td_temple = train_idv_td_temple.drop(['CCY_CD', 'RMB_MID_PRIC'], axis=1) # 按月将金额分类 BY_MONTH_TD = train_idv_td_temple.groupby(['CUST_NO', 'DATA_DAT'])[['CRBAL', 'REG_CAP', 'FXDI_T_ACCM', 'TDOP_SHD_PAY_INTS', 'MOTH_CR_ACCM']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_IDV_TD(key): train_idv_td_temple_STD = BY_MONTH_TD[key].std(axis=1).reset_index() train_idv_td_temple_STD.columns = ['CUST_NO', str('IDV_TD_'+key+'_STD')] train_idv_td_temple_MEAN = BY_MONTH_TD[key].mean(axis=1).reset_index() train_idv_td_temple_MEAN.columns = ['CUST_NO',str('IDV_TD_'+key+'_MEAN')] train_idv_td_temple_MAX = BY_MONTH_TD[key].max(axis=1).reset_index() train_idv_td_temple_MAX.columns = ['CUST_NO',str('IDV_TD_'+key+'_MAX')] train_idv_td_temple_MIN = BY_MONTH_TD[key].min(axis=1).reset_index() train_idv_td_temple_MIN.columns = ['CUST_NO',str('IDV_TD_'+key+'_MIN')] # 合并字段 train_idv_td_temple = pd.merge(train_idv_td_temple_STD, train_idv_td_temple_MEAN, on='CUST_NO', how='inner') train_idv_td_temple = pd.merge(train_idv_td_temple, train_idv_td_temple_MAX, on='CUST_NO', how='inner') train_idv_td_temple = pd.merge(train_idv_td_temple, train_idv_td_temple_MIN, on='CUST_NO', how='inner') train_idv_td_temple = train_idv_td_temple.fillna(0) return train_idv_td_temple train_idv_td_temple = BY_MONTH_IDV_TD('CRBAL') for key in ['REG_CAP', 'FXDI_T_ACCM','TDOP_SHD_PAY_INTS', 'MOTH_CR_ACCM']: train_idv_td_temple = pd.merge(train_idv_td_temple, BY_MONTH_IDV_TD(key)) train_idv_td_temple.drop_duplicates(subset=None, keep='first', inplace=True) return train_idv_td_temple 活期账户12345678910111213141516171819202122232425262728293031323334353637383940414243def BY_MONTH_IDV_DPSA_METHOD(dataset_IDV_DPSA): # 预处理 # 将IDV_DPSA表与汇率表整合 train_idv_dpsa_temple = pd.merge(dataset_IDV_DPSA, train_base_excg, on = 'CCY_CD', how='inner') train_idv_dpsa_temple.drop_duplicates(subset=None, keep='first', inplace=True) # 执行汇率计算函数 train_idv_dpsa_temple['CRBAL'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis=1, args = ('CRBAL', 'RMB_MID_PRIC')) train_idv_dpsa_temple['ITST_BRNG_ACCM'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis=1, args = ('ITST_BRNG_ACCM', 'RMB_MID_PRIC')) train_idv_dpsa_temple['FRZ_TOT_AMT'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('FRZ_TOT_AMT', 'RMB_MID_PRIC')) train_idv_dpsa_temple['DAY_WD_ACT_AMT'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_WD_ACT_AMT', 'RMB_MID_PRIC')) train_idv_dpsa_temple['DAY_CSH_DP_SUM'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_CSH_DP_SUM', 'RMB_MID_PRIC')) train_idv_dpsa_temple['DAY_CSH_WD_SUM'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_CSH_WD_SUM', 'RMB_MID_PRIC')) train_idv_dpsa_temple['DAY_TFI_SUM'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('DAY_TFI_SUM', 'RMB_MID_PRIC')) train_idv_dpsa_temple['MOTH_CR_ACCM'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('MOTH_CR_ACCM', 'RMB_MID_PRIC')) train_idv_dpsa_temple['BEG_MOTH_CRBAL'] = train_idv_dpsa_temple.apply(compute_REAL_MONEY, axis = 1, args = ('BEG_MOTH_CRBAL', 'RMB_MID_PRIC')) train_idv_dpsa_temple = train_idv_dpsa_temple.drop(['CCY_CD', 'RMB_MID_PRIC'], axis=1) # 按月将金额分组 BY_MONTH_DPSA = train_idv_dpsa_temple.groupby(['CUST_NO', 'DATA_DAT'])[['CRBAL', 'ITST_BRNG_ACCM', 'FRZ_TOT_AMT', 'DAY_WD_ACT_AMT', 'DAY_CSH_DP_SUM', 'DAY_CSH_WD_SUM', 'DAY_TFI_SUM', 'MOTH_CR_ACCM', 'BEG_MOTH_CRBAL']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_IDV_DPSA(key): train_idv_dpsa_temple_STD = BY_MONTH_DPSA[key].std(axis=1).reset_index() train_idv_dpsa_temple_STD.columns = ['CUST_NO', str('IDV_DPSA_'+key+'_STD')] train_idv_dpsa_temple_MEAN = BY_MONTH_DPSA[key].mean(axis=1).reset_index() train_idv_dpsa_temple_MEAN.columns = ['CUST_NO',str('IDV_DPSA_'+key+'_MEAN')] train_idv_dpsa_temple_MAX = BY_MONTH_DPSA[key].max(axis=1).reset_index() train_idv_dpsa_temple_MAX.columns = ['CUST_NO',str('IDV_DPSA_'+key+'_MAX')] train_idv_dpsa_temple_MIN = BY_MONTH_DPSA[key].min(axis=1).reset_index() train_idv_dpsa_temple_MIN.columns = ['CUST_NO',str('IDV_DPSA_'+key+'_MIN')] # 合并字段 train_idv_dpsa_temple = pd.merge(train_idv_dpsa_temple_STD, train_idv_dpsa_temple_MEAN, on='CUST_NO', how='inner') train_idv_dpsa_temple = pd.merge(train_idv_dpsa_temple, train_idv_dpsa_temple_MAX, on='CUST_NO', how='inner') train_idv_dpsa_temple = pd.merge(train_idv_dpsa_temple, train_idv_dpsa_temple_MIN, on='CUST_NO', how='inner') train_idv_dpsa_temple = train_idv_dpsa_temple.fillna(0) return train_idv_dpsa_temple train_idv_dpsa_temple = BY_MONTH_IDV_DPSA('CRBAL') for key in ['ITST_BRNG_ACCM','FRZ_TOT_AMT', 'DAY_WD_ACT_AMT', 'DAY_CSH_DP_SUM', 'DAY_CSH_WD_SUM','DAY_TFI_SUM', 'MOTH_CR_ACCM', 'BEG_MOTH_CRBAL']: train_idv_dpsa_temple = pd.merge(train_idv_dpsa_temple, BY_MONTH_IDV_DPSA(key)) train_idv_dpsa_temple.drop_duplicates(subset=None, keep='first', inplace=True) return train_idv_dpsa_temple 交易信息123456789101112131415161718192021222324252627282930313233343536def BY_MONTH_TR_DC_METHOD(dataset_TR_DC): # 预处理 # 去除抹帐(1),无意义列，这里全是0 dataset_TR_DC = dataset_TR_DC[dataset_TR_DC['CAN_IND']==0].drop(['RED_BLU_CD', 'CRD_TYP1', 'TR_TYPE', 'TR_CHANL_CD', 'CAN_IND', 'CARD_USETYPE', 'CARD_ELECASH', 'CARD_MATERIAL'],axis=1) dataset_TR_DC.drop_duplicates(subset=None, keep='first', inplace=True) # 交易表时间段打上标签 # 2月份 [3726432000, 3728937600), 3月份 [3728937600, 3731616000), 4月份 [3731616000, 3734035200] dataset_TR_DC['TR_DAT'] = pd.cut(dataset_TR_DC['TR_DAT'], [3726432000, 3728937600, 3731616000, 3734035200], labels=['2月份', '3月份', '4月份']) # 将交易按照 正 / 负 分开 train_tr_dc['INCOME'] = train_tr_dc['TR_AMT'] &gt; 0 myseries = train_tr_dc.groupby(['CUST_NO', 'INCOME'])['TR_AMT'].sum() myseries = myseries.unstack().fillna(0) TR_DC_IN_OUT = pd.DataFrame(myseries).reset_index() TR_DC_IN_OUT['IN_SUM'] = TR_DC_IN_OUT[True] TR_DC_IN_OUT['OUT_SUM'] = TR_DC_IN_OUT[False] TR_DC_IN_OUT = TR_DC_IN_OUT.drop([True, False], axis=1) BY_MONTH_DC = dataset_TR_DC.groupby(['CUST_NO', 'TR_DAT'])[['TR_AMT']].sum().unstack() # 声明函数 计算三个月的标准差、均值、最大值、最小值 def BY_MONTH_TR_DC(key): train_tr_dc_temple_STD = BY_MONTH_DC[key].std(axis=1).reset_index() train_tr_dc_temple_STD.columns = ['CUST_NO', str('TR_DC_'+key+'_STD')] train_tr_dc_temple_MEAN = BY_MONTH_DC[key].mean(axis=1).reset_index() train_tr_dc_temple_MEAN.columns = ['CUST_NO',str('TR_DC_'+key+'_MEAN')] train_tr_dc_temple_MAX = BY_MONTH_DC[key].max(axis=1).reset_index() train_tr_dc_temple_MAX.columns = ['CUST_NO',str('TR_DC_'+key+'_MAX')] train_tr_dc_temple_MIN = BY_MONTH_DC[key].min(axis=1).reset_index() train_tr_dc_temple_MIN.columns = ['CUST_NO',str('TR_DC_'+key+'_MIN')] # 合并字段 train_tr_dc_temple = pd.merge(train_tr_dc_temple_STD, train_tr_dc_temple_MEAN, on='CUST_NO', how='inner') train_tr_dc_temple = pd.merge(train_tr_dc_temple, train_tr_dc_temple_MAX, on='CUST_NO', how='inner') train_tr_dc_temple = pd.merge(train_tr_dc_temple, train_tr_dc_temple_MIN, on='CUST_NO', how='inner') train_tr_dc_temple = train_tr_dc_temple.fillna(0) return train_tr_dc_temple train_tr_dc_temple = BY_MONTH_TR_DC('TR_AMT') return train_tr_dc_temple 1train_tr_dc['TR_DAT'] = pd.cut(train_tr_dc['TR_DAT'], [3726432000, 3728937600, 3731616000, 3734035200], labels=['FEB', 'MAR', 'APR']) 1BY_MONTH_TR_DC_METHOD = train_tr_dc[['TR_DAT']] 1sns.countplot(x='TR_DAT', data=BY_MONTH_TR_DC_METHOD) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f0167e23a58&gt; 年龄123456789101112# 返回单个 或 series 的ms对应日期, 再被 2015 减得到的年数def adj_date(series, datatype='series'): import time from datetime import datetime initial_year = 2015 adj_msj_obj = datetime.strptime("2042-08-31 16:00:00.123", "%Y-%m-%d %H:%M:%S.%f") adj_ms = int(time.mktime(adj_msj_obj.timetuple())*1000 + adj_msj_obj.microsecond/1000.0)/1000 current_ms = train_idv_cust_basic['DATA_DAT'][0] # 3736713600 if(datatype=='single'): return initial_year - int(time.strftime("%Y%m", time.localtime(current_ms-adj_ms))) else: return series.map(lambda x: initial_year - int(time.strftime("%Y", time.localtime(x - adj_ms))) if pd.notna(x) else x) 1234567# 年龄计算函数def CALC_AGE(dataset_idv_cust_basic): dataset_idv_cust_basic['GC_BRTH'] = dataset_idv_cust_basic['GC_BRTH'].fillna(dataset_idv_cust_basic['GC_BRTH'].mean()) dataset_idv_cust_basic['AGE'] = adj_date(dataset_idv_cust_basic['GC_BRTH']) dataset_idv_cust_basic['AGE'] = np.where(dataset_idv_cust_basic['AGE'] &gt; 100, 31, dataset_idv_cust_basic['AGE']) dataset_idv_cust_basic['AGE'] = np.where(dataset_idv_cust_basic['AGE'] &lt; 16, 31, dataset_idv_cust_basic['AGE']) return dataset_idv_cust_basic 1AGE = CALC_AGE(train_idv_cust_basic)['AGE'] 1AGE.hist() &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f01681b5cc0&gt; /root/anaconda3/lib/python3.6/site-packages/matplotlib/font_manager.py:1320: UserWarning: findfont: Font family [&apos;sans-serif&apos;] not found. Falling back to DejaVu Sans (prop.get_family(), self.defaultFamily[fontext])) 所有资产123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# td定期、bond国债、fund基金、prec_metal贵金属、aget_insr保险def WEALTH(target,td,bond,fund,prec_metal,agent_insurance,thr_pty_cstd): ''' # 销户日期必须 &gt; 2月底，合约建立日期必须 &lt; 4月底 #gp = df_tr_train.groupby(['CUST_NO','TR_CD']).agg(&#123;'TR_AMT':['sum','mean','max','min','count','std']&#125;) if len(suffix)==1: td = td[td['DATA_DAT']==time_point[1]] bond = bond[bond['DATA_DAT']==time_point[1]] fund = fund[fund['DATA_DAT']==time_point[1]] prec_metal = prec_metal[prec_metal['DATA_DAT']==time_point[1]] agent_insurance = agent_insurance[agent_insurance['DATA_DAT']==time_point[1]] thr_pty_cstd = thr_pty_cstd[thr_pty_cstd['DATA_DAT']==time_point[1]] elif len(suffix)==2: td = td[td['DATA_DAT']&gt;time_point[1]] bond = bond[bond['DATA_DAT']&gt;time_point[1]] fund = fund[fund['DATA_DAT']&gt;time_point[1]] prec_metal = prec_metal[prec_metal['DATA_DAT']&gt;time_point[1]] agent_insurance = agent_insurance[agent_insurance['DATA_DAT']&gt;time_point[1]] thr_pty_cstd = thr_pty_cstd[thr_pty_cstd['DATA_DAT']&gt;time_point[1]] ''' # 选取各表合并特征 td = td[['CUST_NO','DATA_DAT','CRBAL','MOTH_CR_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() bond = bond[['CUST_NO','DATA_DAT','ARG_CUR_BAL','NVTA_MOTH_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() fund = fund[['CUST_NO','DATA_DAT','FUND_BAL','FUND_BAL_MOTH_BAL_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() prec_metal = prec_metal[['CUST_NO','DATA_DAT','ARG_BAL','MTH_ARG_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() agent_insurance = agent_insurance[['CUST_NO','DATA_DAT','BEG_MTH_PREM_BAL','MTH_PREM_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() thr_pty_cstd = thr_pty_cstd[['CUST_NO','DATA_DAT','AVL_BAL','MTH_ARG_BAL_ACCM']].groupby(['CUST_NO','DATA_DAT']).sum().unstack().reset_index() # 理财各月的金额、持有产品的数量、 wealth = pd.merge(target[['CUST_NO']],td,on=['CUST_NO'],how='outer') wealth = pd.merge(wealth,bond,on=['CUST_NO'],how='outer') wealth = pd.merge(wealth,fund,on=['CUST_NO'],how='outer') wealth = pd.merge(wealth,prec_metal,on=['CUST_NO'],how='outer') wealth = pd.merge(wealth,thr_pty_cstd,on=['CUST_NO'],how='outer') wealth = pd.merge(wealth,agent_insurance,on=['CUST_NO'],how='outer').fillna(0) # 理财各月的金额、持有产品的数量、 #wealth['WEALTH_BAL'] = wealth['CRBAL'] + wealth['ARG_CUR_BAL'] + wealth['FUND_BAL'] + wealth['ARG_BAL'] + wealth['BEG_MTH_PREM_BAL'] #+ wealth['AVL_BAL'] #wealth['WEALTH_ACCM'] = wealth['MOTH_CR_ACCM'] + wealth['NVTA_MOTH_ACCM'] + wealth['FUND_BAL_MOTH_BAL_ACCM'] + wealth['MTH_ARG_ACCM'] + wealth['MTH_PREM_ACCM'] #+ wealth['MTH_ARG_BAL_ACCM'] #wealth = wealth.groupby(['CUST_NO'])['WEALTH_BAL','WEALTH_ACCM'].sum().reset_index() # 持有的理财产品种类（不同期限/合约建立日期、相同品种的算不同产品） # 首份理财合约建立时间、最近一份理财合约建立时间 # 3个月内买入理财产品次数 # 3个月存款积数之和（活期，活期+定期+三方存管） X = wealth.copy() X['WEALTH_BAL_1'] = X[('CRBAL', 3728764800)]+X[('ARG_CUR_BAL', 3728764800)]+X[('FUND_BAL', 3728764800)]+X[('ARG_BAL', 3728764800)]+X[('AVL_BAL', 3728764800)]+X[('BEG_MTH_PREM_BAL', 3728764800)] X['WEALTH_BAL_2'] = X[('CRBAL', 3731443200)]+X[('ARG_CUR_BAL', 3731443200)]+X[('FUND_BAL', 3731443200)]+X[('ARG_BAL', 3731443200)]+X[('AVL_BAL', 3731443200)]+X[('BEG_MTH_PREM_BAL', 3731443200)] X['WEALTH_BAL_3'] = X[('CRBAL', 3734035200)]+X[('ARG_CUR_BAL', 3734035200)]+X[('FUND_BAL', 3734035200)]+X[('ARG_BAL', 3734035200)]+X[('AVL_BAL', 3734035200)]+X[('BEG_MTH_PREM_BAL', 3734035200)] X['WEALTH_ACCM_1'] = X[('MOTH_CR_ACCM', 3728764800)]+X[('NVTA_MOTH_ACCM', 3728764800)]+X[('FUND_BAL_MOTH_BAL_ACCM', 3728764800)]+X[('MTH_ARG_ACCM', 3728764800)]+X[('MTH_ARG_BAL_ACCM', 3728764800)]+X[('MTH_PREM_ACCM', 3728764800)] X['WEALTH_ACCM_2'] = X[('MOTH_CR_ACCM', 3731443200)]+X[('NVTA_MOTH_ACCM', 3731443200)]+X[('FUND_BAL_MOTH_BAL_ACCM', 3731443200)]+X[('MTH_ARG_ACCM', 3731443200)]+X[('MTH_ARG_BAL_ACCM', 3731443200)]+X[('MTH_PREM_ACCM', 3731443200)] X['WEALTH_ACCM_3'] = X[('MOTH_CR_ACCM', 3734035200)]+X[('NVTA_MOTH_ACCM', 3734035200)]+X[('FUND_BAL_MOTH_BAL_ACCM', 3734035200)]+X[('MTH_ARG_ACCM', 3734035200)]+X[('MTH_ARG_BAL_ACCM', 3734035200)]+X[('MTH_PREM_ACCM', 3734035200)] X2 = X[['CUST_NO','WEALTH_BAL_1','WEALTH_BAL_2','WEALTH_BAL_3','WEALTH_ACCM_1','WEALTH_ACCM_2','WEALTH_ACCM_3']].set_index('CUST_NO') X2['WEALTH_BAL_MAX'] = X2[['WEALTH_BAL_1','WEALTH_BAL_2','WEALTH_BAL_3']].max(axis=1) X2['WEALTH_BAL_MEAN'] = X2[['WEALTH_BAL_1','WEALTH_BAL_2','WEALTH_BAL_3']].mean(axis=1) X2['WEALTH_BAL_STD'] = X2[['WEALTH_BAL_1','WEALTH_BAL_2','WEALTH_BAL_3']].std(axis=1).fillna(0.0) X2['WEALTH_BAL_CV'] = X2['WEALTH_BAL_STD']/X2['WEALTH_BAL_MEAN'] X2['WEALTH_ACCM_MAX'] = X2[['WEALTH_ACCM_1','WEALTH_ACCM_2','WEALTH_ACCM_3']].max(axis=1) X2['WEALTH_ACCM_MEAN'] = X2[['WEALTH_ACCM_1','WEALTH_ACCM_2','WEALTH_ACCM_3']].mean(axis=1) X2['WEALTH_ACCM_STD'] = X2[['WEALTH_ACCM_1','WEALTH_ACCM_2','WEALTH_ACCM_3']].std(axis=1).fillna(0.0) X2['WEALTH_ACCM_CV'] = X2['WEALTH_ACCM_STD']/X2['WEALTH_ACCM_MEAN'] X3 = X2.fillna(0.0).drop(['WEALTH_BAL_1','WEALTH_BAL_2','WEALTH_BAL_3','WEALTH_ACCM_1','WEALTH_ACCM_2','WEALTH_ACCM_3','WEALTH_BAL_STD','WEALTH_ACCM_STD'],axis=1).reset_index() return X3[['CUST_NO','WEALTH_ACCM_MEAN','WEALTH_ACCM_CV']] 结果挖掘12train_cust_result_1 = train_cust_result[train_cust_result['FLAG']==1]train_cust_result_0 = train_cust_result[train_cust_result['FLAG']==0] 1from lightgbm import LGBMRegressor 1! pip install lightgbm-2.2.3-py2.py3-none-manylinux1_x86_64.whl Processing ./lightgbm-2.2.3-py2.py3-none-manylinux1_x86_64.whl Requirement already satisfied: scikit-learn in /root/anaconda3/lib/python3.6/site-packages (from lightgbm==2.2.3) Requirement already satisfied: scipy in /root/anaconda3/lib/python3.6/site-packages (from lightgbm==2.2.3) Requirement already satisfied: numpy in /root/anaconda3/lib/python3.6/site-packages (from lightgbm==2.2.3) Installing collected packages: lightgbm Successfully installed lightgbm-2.2.31! cp ./xgb_rfm-Copy1.ipynb ./xgb_rfm-Copy2.ipynb 1! pip install imbalanced-learn Requirement already satisfied: imbalanced-learn in /root/anaconda3/lib/python3.6/site-packages Requirement already satisfied: scipy&gt;=0.17 in /root/anaconda3/lib/python3.6/site-packages (from imbalanced-learn) Requirement already satisfied: joblib&gt;=0.11 in /root/anaconda3/lib/python3.6/site-packages (from imbalanced-learn) Requirement already satisfied: scikit-learn&gt;=0.21 in /root/anaconda3/lib/python3.6/site-packages (from imbalanced-learn) Requirement already satisfied: numpy&gt;=1.11 in /root/anaconda3/lib/python3.6/site-packages (from imbalanced-learn)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装MySQL 8.0]]></title>
    <url>%2F2019%2F02%2F27%2FCentOS%E5%AE%89%E8%A3%85MySQL8%2F</url>
    <content type="text"><![CDATA[CentOS MySQL的安装和配置记录。 安装MySQL 打开官网 https://dev.mysql.com/downloads/repo/yum/ 下载(mysql80-community-release-el7-2.noarch.rpm)rpm文件 通过 WinSCP将文件上传至 /usr/ 目录下 本地安装 1yum install mysql80-community-release-el7-2.noarch.rpm 查看MySQL 的所有版本 1yum repolist all | grep mysql 默认会下载最新的版本，可以通过 12sudo yum-config-manager --disable mysql80-communitysudo yum-config-manager --enable mysql57-community 来调整默认版本， 也可以通过修改 /etc/yum.repos.d/mysql-community.repo 中enabled的值(1 或 0)来进行修改。6. 安装MySQL 1sudo yum install mysql-community-server 启动MySQL 1sudo service mysqld start 用临时密码登录 123456 sudo grep 'temporary password' /var/log/mysqld.log mysql -uroot -p # 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';# 查看MySQL版本 SHOW VARIABLES WHERE Variable_name = 'version'; 允许远程连接MySQL数据库 123456# 首先确保3306端口开放user mysql# 创建用户CREATE USER 'myuser'@'%' IDENTIFIED BY 'password'; (myuser 和 password 替换)GRANT ALL ON *.* TO 'myuser'@'%' WITH GRANT OPTION; (myuser 替换)FLUSH PRIVILEGES;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro 安全框架学习笔记]]></title>
    <url>%2F2019%2F02%2F26%2FShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[记录我学习安全框架Shiro的一些笔记。 Shiro VS Spring SecurityApache Shiro简单灵活，可脱离Spring，粒度较粗；可以自己拓展，适合通过资源进行权限控制；Spring Security复杂笨重，不可脱离Spring，力度更细；适合做数据权限控制； Shiro的认证过程 创建Security Manager 主体提交认证 Security Manager认证 Authenticator认证 Realm认证 代码如下：java代码 1234567891011121314151617181920212223242526272829303132333435363738394041package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AuthenticationTest &#123; SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before public void addUser() &#123; simpleAccountRealm.addAccount("LEEZY", "123456"); &#125; @Test public void testAuthentication() &#123; // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); // 将SimpleAccountRealm设置到环境变量中来 defaultSecurityManager.setRealm(simpleAccountRealm); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("LEEZY", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.isAuthenticated(); subject.logout(); System.out.println("isAuthenticated: " + subject.isAuthenticated()); &#125;&#125; pom文件 1234567891011121314151617181920212223242526272829&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leezy.shiro&lt;/groupId&gt; &lt;artifactId&gt;shirotest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;shirotest&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;/.&lt;/project&gt; Shiro授权 创建 Security Manager 主体授权 Security Manager 授权 Authorizer认证 Realm 获取角色权限数据 123456789101112131415161718192021222324252627282930313233343536373839404142package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AuthenticationTest &#123; SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before public void addUser() &#123; simpleAccountRealm.addAccount("LEEZY", "123456", "admin", "user"); &#125; @Test public void testAuthentication() &#123; // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); // 将SimpleAccountRealm设置到环境变量中来 defaultSecurityManager.setRealm(simpleAccountRealm); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("LEEZY", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.isAuthenticated(); // 检查一个角色 // subject.checkRole("admin"); // 检查是否具备参数里所有的角色，通过遍历参数来进行授权 subject.checkRoles("admin", "user"); &#125;&#125; InitRealm的使用1234567891011121314151617181920212223242526272829303132333435package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.text.IniRealm;import org.apache.shiro.subject.Subject;import org.junit.Test;public class InitRealmTest &#123; @Test public void testAuthentication() &#123; IniRealm iniRealm = new IniRealm("classpath:user.ini"); // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(iniRealm); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("LEEZY", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.checkRole("admin"); subject.checkPermission("user:delete"); subject.checkPermission("user:update"); &#125;&#125; user.ini 1234[users]LEEZY=123456,admin[roles]admin=user:delete,user:update JDBCRealm的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.jdbc.JdbcRealm;import org.apache.shiro.subject.Subject;import org.junit.Test;import com.alibaba.druid.pool.DruidDataSource;public class JdbcRealmTest &#123; DruidDataSource dataSource = new DruidDataSource(); &#123; dataSource.setUrl("jdbc:mysql://192.168.56.101:3306/test"); dataSource.setUsername("root"); dataSource.setPassword("Zdh!123456"); &#125; @Test public void testAuthentication() &#123; JdbcRealm jdbcRealm = new JdbcRealm(); jdbcRealm.setDataSource(dataSource); // 开启后才可以进行权限认证(默认关闭) jdbcRealm.setPermissionsLookupEnabled(true); String select_sql = "select password from test_user where username = ?"; jdbcRealm.setAuthenticationQuery(select_sql); String role_sql = "select role_name from test_user_role where user_name = ?"; jdbcRealm.setUserRolesQuery(role_sql); // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(jdbcRealm); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("SAKURA", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.checkRole("admin"); subject.checkPermission("user:select"); &#125;&#125; pom.xml 123456789101112&lt;!-- MySQL驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.14&lt;/version&gt;&lt;/dependency&gt; 查看JdbcRealm源码可以发现，它有默认的SQL查询语句，只要建立相应的数据表就可以。 自定义Realm自定义Realm继承AuthorizingRealm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.leezy.shiro.realm;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;public class CustomRealm extends AuthorizingRealm&#123; Map&lt;String, String&gt; userMap = new HashMap&lt;String, String&gt;(16); &#123; userMap.put("LEEZY", "123456"); super.setName("CustomRealm"); &#125; // 授权 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; String username = (String) principals.getPrimaryPrincipal(); // 从数据库或者缓存中获取角色数据 Set&lt;String&gt; roles = getRolesByUserName(username); Set&lt;String&gt; permissions = getPermissionsByUserName(username); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setRoles(roles); info.setStringPermissions(permissions); return info; &#125; // 认证 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //1 从主体传过来的认证信息中获得用户名 String username = (String) token.getPrincipal(); //2.通过用户名到数据库中获取凭证 String password = getPasswordByUserName(username); if(password == null) &#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo("LEEZY", password, "CustomRealm"); return authenticationInfo; &#125; // 模拟数据库中权限查询 private Set&lt;String&gt; getPermissionsByUserName(String username) &#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); sets.add("user:delete"); sets.add("user:add"); return sets; &#125; // 模拟数据库中角色查询 public Set&lt;String&gt; getRolesByUserName(String username) &#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); sets.add("admin"); sets.add("user"); return sets; &#125; // 模拟数据库的查询凭证 private String getPasswordByUserName(String username) &#123; return userMap.get(username); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;import org.junit.Test;import com.leezy.shiro.realm.CustomRealm;public class CustomRealmTest &#123; @Test public void testAuthentication() &#123; CustomRealm customRealm = new CustomRealm(); // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(customRealm); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("LEEZY", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.checkRole("admin"); subject.checkPermission("user:delete"); subject.checkPermission("user:add"); &#125;&#125; Shiro加密Shiro加密方式： HashedCredentialsMatcher 自定义Realm中使用散列 盐的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.leezy.shiro.realm;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.crypto.hash.Md5Hash;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;public class CustomRealm extends AuthorizingRealm&#123; Map&lt;String, String&gt; userMap = new HashMap&lt;String, String&gt;(16); &#123; // 使用加密之后的密文 userMap.put("LEEZY", "e43a7da8514a1c9d566164b3ea731a4a"); super.setName("CustomRealm"); &#125; // 授权 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; String username = (String) principals.getPrimaryPrincipal(); // 从数据库或者缓存中获取角色数据 Set&lt;String&gt; roles = getRolesByUserName(username); Set&lt;String&gt; permissions = getPermissionsByUserName(username); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setRoles(roles); info.setStringPermissions(permissions); return info; &#125; // 认证 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //1 从主体传过来的认证信息中获得用户名 String username = (String) token.getPrincipal(); //2.通过用户名到数据库中获取凭证 String password = getPasswordByUserName(username); if(password == null) &#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo("LEEZY", password, "CustomRealm"); // 将盐设置进去 authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes("SAKURA")); return authenticationInfo; &#125; // 模拟数据库中权限查询 private Set&lt;String&gt; getPermissionsByUserName(String username) &#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); sets.add("user:delete"); sets.add("user:add"); return sets; &#125; // 模拟数据库中角色查询 public Set&lt;String&gt; getRolesByUserName(String username) &#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); sets.add("admin"); sets.add("user"); return sets; &#125; // 模拟数据库的查询凭证 private String getPasswordByUserName(String username) &#123; return userMap.get(username); &#125; public static void main(String[] args) &#123; // MD5 + 加盐 Md5Hash md5Hash = new Md5Hash("123456", "SAKURA"); System.out.println(md5Hash.toString()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.leezy.shiro.shirotest;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;import org.junit.Test;import com.leezy.shiro.realm.CustomRealm;public class CustomRealmTest &#123; @Test public void testAuthentication() &#123; CustomRealm customRealm = new CustomRealm(); // 1. 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(customRealm); HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(); // 设置加密方式 matcher.setHashAlgorithmName("md5"); // 设置加密次数 matcher.setHashIterations(1); customRealm.setCredentialsMatcher(matcher); // 2. 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("LEEZY", "123456"); subject.login(token); System.out.println("isAuthenticated: " + subject.isAuthenticated()); subject.checkRole("admin"); subject.checkPermission("user:delete"); subject.checkPermission("user:add"); &#125;&#125; Shiro集成Spring]]></content>
      <tags>
        <tag>SHIRO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse使用技巧]]></title>
    <url>%2F2019%2F02%2F15%2FEclipse%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Eclipse 搭建Maven相关项目的使用技巧。 快捷键说明：Ctrl + Shift + L 可以查看常用快捷键，超级好用！]]></content>
      <tags>
        <tag>DEV-TOOL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 常用命令总结]]></title>
    <url>%2F2019%2F02%2F03%2FCentOS7%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常用的CentOS命令总结，方便查看与记忆。 Linux常用命令(1)查看DNS记录的命令（A记录、MX记录） 123yum install bind-utilsdig +noall +answer www.leezy.top (2) 查看端口常用命令： 1netstat -lnp|grep 80 (3) 查看版本 12ll /etc/*centos*cat /etc/centos-release (4) 查看内核经常在执行 yum udpate 命令后CentOS会出现多个启动项，所以我们经常要删除： 12345678# 查看当前系统正在使用的内核版本uname -a# 查看当前系统的全部Kernelrpm -q kernel# 删除多余的内核启动项yum remove kernel-3.10.0-957.el7.x86_64# 重新启动reboot (5) 修改主机名 123hostnamectl set-hostname NAME# 重启机器reboot CentOS Minimal版本配置换源：http://mirrors.163.com/.help/centos.html 安装软件123yum install net-toolsyum install wgetyum install vim 配置JAVA环境变量12345678910111213141516171819202122vim /etc/profile# 在文件末尾添加环境配置export JAVA_HOME=/usr/jdk-11.0.2export CLASSPATH=.:$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:$&#123;JAVA_HOME&#125;/lib/dt.jar:$&#123;JAVA_HOME&#125;/lib/tools.jarexport PATH=$PATH:$&#123;JAVA_HOME&#125;/bin# 使新的环境生效source /etc/profile# 当Java版本更新时，仅仅修改JAVA_HOME的路径是不够的，需要删除链接which java/usr/jdk_xxx/bin/javawhich javac /usr/jdk_xxx_/bin/javac# 删除链接rm -rf /usr/jdk_xxx/bin/javarm -rf /usr/jdk_xxx_/bin/javac# 再执行使得新环境生效source /etc/profile GitLab CE版安装新建 /etc/yum.repos.d/gitlab-ce.repo，内容为： 12345[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1 再执行： 1234567891011sudo yum install curl openssh-server openssh-clients postfix croniesudo service postfix startsystemctl enable postfix.service(yum install lokkit)sudo lokkit -s http -s sshsudo yum makecachesudo yum install gitlab-ce#启动GitLabsudo gitlab-ctl reconfigure 常用的网络配置修改DNS(貌似会重启失效) 1vim /etc/resolv.conf 修改IP地址 1vim /etc/sysconfig/network-scripts/ifcfg-enp0s3 清理内存1234echo 3 &gt; /proc/sys/vm/drop_caches# 查看内存使用情况free -h Docker配置由于直接使用DockerHub下载的速度很慢，所以可以使用阿里云的容器镜像加速服务： 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["加速器地址"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 这样就可以快速的使用Docker pull 等命令了。清理Dcoker 容器： 1docker system prune 开放防火墙端口12345678# --permanent 永久生效firewall-cmd --zone=public --add-port=9092/tcp --permanent# 重新载入firewall-cmd --reload# 查看firewall-cmd --zone=public --query-port=80/tcp# 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重新定义SpringCloud实战》读书笔记]]></title>
    <url>%2F2018%2F12%2F18%2FSpringCloud%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SpringCloud提供了快速构建分布式中常见模式的工具，包括配置管理、服务发现、断路器、智能路由、微代理、控制总线等。SpringCloud中间件是基于SpringBoot的实现，提供了对微服务完整的一套解决方案。 应用架构的发展历程：单体应用架构 –&gt; 分布式架构 –&gt;面向服务的SOA架构 –&gt; 微服务架构SOA架构个人理解是多个应用之间通过企业数据总线ESB通信的架构，其应用程序通过网络协议提供服务，消费服务，不同业务提供不同的服务。(阿里的服务治理框架Dubbo)微服务架构：一个大型的应用拆分为多个相互独立的微服务，每个服务之间松耦合，通过REST API或者HTTP进行通信。 SpringCloud包包含以下组件：服务治理组件 Eureka / Consul + 客户端负载均衡组件 Ribbon + 声明式服务调用组件 Feign + API网关治理组件 Zuul / GateWay(高并发) + 熔断机制 HyStrix + 分布式配置中心组件 Spring Cloud Config / 携程 Apollo + 消息总线组件 Bus + 消息驱动组件 Stream + 分布式服务跟踪组件 Sleuth + 全链路监控 SkyWalking. Tips: 代码基于Spring Cloud Finchley 版本 服务治理：Spring Cloud Eureka负责微服务架构中的服务治理功能，即各个微服务实例的自动化注册与发现。SpringCloud Eureka 是由 Netflix Eureka实现的，即包含了服务端组件也包含了客户端组件。Eureka服务端也被称为服务注册中心，各个微服务启动时会向Eureka Server 注册自己的信息。代码如下：在https://start.spring.io/ 中新建一个Eureka Server的Demo，或者直接在Maven项目中的pom.xml文件中添加如下Dependence: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; EurekaServerApplication.java 1234567891011121314151617package com.leezy.eureka_server;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication//该注解启动一个服务注册中心提供给其他应用会话@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; System.out.println("Hello Eureka Server!"); SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; Eureka Server 中的 application.yml 和 application-standalone.yml 12345678910111213141516# application.ymlspring: profiles: active: standalone jackson: serialization: FAIL_ON_EMPTY_BEANS: falseeureka: server: use-read-only-response-cache: false response-cache-auto-expiration-in-seconds: 10management: endpoints: web: exposure: include: '*' 123456789101112131415# application-standalone.ymlserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false #是否将自己注册到Eureka Server, 默认为True fetchRegistry: false #是否需要从Eureka Server获取注册信息, 默认为Ture serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 查询服务和注册服务的地址，多个用","隔开 server: waitTimeInMsWhenSyncEmpty: 0 enableSelfPreservation: false 打开 http://localhost:8761/ 看到Eureka的控制面板。Eureka服务注册端， Eureka Client将微服务注册到Eureka Server上。EurekaClientApplication.java 1234567891011121314151617package com.leezy.eureka_client;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication// 该注解适配性比较好，可以用于多种服务发现组件(Zookeeper、Consul)@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; System.out.println("Hello Eureka Client!"); SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; Maven依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; Eureka Client的配置文件： application.yml 和 application-demo.yml 1234#application.ymlspring: profiles: active: demo 1234567891011121314#application-demo.ymlserver: port: 8081Spring: application: name: demo-leezy #声明服务提供者的应用名称eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #设置与Eureka Server交互的地址 instance: prefer-ip-address: true 刷新Eureka控制台就可以看到注册到Server上的服务了。 Eureka的设计理念： 服务实例如何注册到服务中心：（1）调用Eureka Server的REST API 的 register方法（2）Java语言使用者可以调用NetFlix的Eureka Client封装的API（3）Spring Cloud使用者在pom.xml文件中引用 spring-cloud-starter-netflix-eureka-client，基于Spring Boot的自动配置即可。 服务实例从服务中心剔除（1）服务实例正常关闭时，通过钩子方法或者生命周期回调方法调用Eureka Server 的REST API的de-register方法。（2）Eureka要求Client定时续约(30s)，如果90s没有续约操作则Eureka Server主动剔除该操作。 服务实例信息的一致性问题服务注册与发现中心应该也是一个集群，如何保证一致性（1）AP优于CP (Zookeeper-CP, Eureka-AP)（2）Peer to Peer架构(1. 主从复制 2. 对等复制)（3）Zone及Region设计（4）SELF PRESERVATION设计 WebService客户端 FeignFeign是一个声明式的Web Service客户端，用于服务与服务之间的调用，支持SpringMVC注解，整合了Ribbon以及Hystrix。对应的POM依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 应用入口程序SpringCloudFeignApplication.java 123456789101112131415package com.leezy.hello_feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class HelloFeignApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(HelloFeignApplication.class, args); &#125;&#125; 接口类：HelloFeignService.java，作用是应用指定的URL最终转化为Github API允许的URL。eg：https://api.github.com/search/repositories?q=spring-cloud(Github RestAPI的文档：https://developer.github.com/v3/search/) 1234567891011121314package com.leezy.hello_feign.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import com.leezy.hello_feign.config.HelloFeignServiceConfig;@FeignClient(name = "github-client", url = "https://api.github.com", configuration = HelloFeignServiceConfig.class)public interface HelloFeignService &#123; @RequestMapping(value = "/search/repositories", method = RequestMethod.GET) String searchRepo(@RequestParam(name = "q") String quertStr);&#125; 控制类：HelloFeignController.java，作用：调用服务提供者的接口 123456789101112131415161718192021package com.leezy.hello_feign.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.leezy.hello_feign.service.HelloFeignService;@RestControllerpublic class HelloFeignController &#123; @Autowired private HelloFeignService helloFeignService; @GetMapping(value = "/search/github") public String searchGithubRepoByStr(@RequestParam("str") String queryStr) &#123; return helloFeignService.searchRepo(queryStr); &#125;&#125; 配置类：HelloFeignServiceConfig.java，@Bean注解配置日志的bean 123456789101112131415package com.leezy.hello_feign.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import feign.Logger;@Configurationpublic class HelloFeignServiceConfig &#123; @Bean Logger.Level feignLoggerLevel() &#123; //level有四个级别 return Logger.Level.FULL; &#125;&#125; 配置文件: application.yml 123456789server: port: 8010spring: application: name: Hello Feignlogging: level: com.leezy.hello_feign.service.HelloFeignService: DEBUG #在这里配置日志的输出级别 启动应用后，访问网址：http://localhost:8010/search/github?str=spring-cloudFeign支持的属性文件配置方式有两种：application.yml(application.properties) 以及 Java方式的配置类，但是配置文件的优先级会高于Java类的优先级。Feign默认的是JDK原生的URL Connection，并没有使用连接池，可以用Http Client和 okHttp进行替换对项目进行调优。 Feign 的 POST 和 GET 的多参数传递Feign拦截器，将Json转化为Map。实现Feign的RequestInterceptor中的apply方法来进行统一拦截转换处理Feign中的GET方法多参数传递问题。集成Swapper，编写服务消费者用于调用Feign进行Get或Post多参数传递。 负载均衡组件 RibbonFeign中集成了Ribbon，但是Ribbon可以单独使用，它是一种进程内负载均衡器（客户端负载均衡），它赋予了应用支配Http和Tcp的能力。负载均衡策略：最常用的是RoundRobinRule 轮询策略代码样例：pom.xml 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动类：RibbonLoadbalancerApplication.java注入一个RestTemplate的Bean，并且使用@LoadBalances注解才能使其具备负载均衡的能力。 1234567891011121314151617181920212223package cn.springcloud.book;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplication@EnableDiscoveryClientpublic class RibbonLoadbalancerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonLoadbalancerApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; TestController.javaRibbon客户端需要创建一个API来调用Eureka源服务自定义的API 12345678910111213141516171819import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/add") public String add(Integer a, Integer b) &#123; String result = restTemplate .getForObject("http://CLIENT-A/add?a=" + a + "&amp;b=" + b, String.class); System.out.println(result); return result; &#125;&#125; 通过查找继承关系，发现接口ILoadBalancer的实现抽象类AbstractLoadBalancer的实现类BaseLoadBalancer中的chooseServer方法是真正实现负载均衡的地方。 123456789101112131415161718192021/* * Get the alive server dedicated to key * * @return the dedicated server */public Server chooseServer(Object key) &#123; if (counter == null) &#123; counter = createCounter(); &#125; counter.increment(); if (rule == null) &#123; return null; &#125; else &#123; try &#123; return rule.choose(key); &#125; catch (Exception e) &#123; logger.warn("LoadBalancer [&#123;&#125;]: Error choosing server for key &#123;&#125;", name, key, e); return null; &#125; &#125;&#125; 熔断机制 Spring Cloud HystrixHystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.Hystrix的设计目标是： 通过客户端对延迟和故障进行保护和控制 在一个复杂的分布式系统中停止级联故障 快速失败和迅速恢复 在合理的情况下回退和优雅地降级 开启实时监控、告警和操作控制pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.leezy&lt;/groupId&gt; &lt;artifactId&gt;hystrix&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hystrix&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; ClientApplication.java 123456789101112131415package com.leezy.hystrix;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@SpringBootApplication@EnableHystrix@EnableDiscoveryClientpublic class ClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApplication.class, args); &#125;&#125; TestController.java 12345678910111213141516171819package com.leezy.hystrix.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.leezy.hystrix.service.IUserService;@RestControllerpublic class TestController &#123; @Autowired private IUserService userService; @GetMapping("/getUser") public String getUser(@RequestParam String username) throws Exception&#123; return userService.getUser(username); &#125;&#125; IUserService.java 12345package com.leezy.hystrix.service;public interface IUserService &#123; public String getUser(String username) throws Exception;&#125; UserService.java 12345678910111213141516171819202122232425package com.leezy.hystrix.service.impl;import org.springframework.stereotype.Component;import com.leezy.hystrix.service.IUserService;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;@Componentpublic class UserService implements IUserService&#123; // 降级处理 @Override @HystrixCommand(fallbackMethod="defaultUser") public String getUser(String username) throws Exception &#123; if (username.equals("spring")) &#123; return "This is real user."; &#125; else &#123; throw new Exception(); &#125; &#125; public String defaultUser(String username) &#123; return "The User does not exist in the system...Test!"; &#125;&#125; bootstrap.yml 1234567891011server: port: 8888spring: application: name: hystrix-client-serviceeureka: client: serviceUrl: defaultZone: http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8761&#125;/eureka/ instance: prefer-ip-address: true 打开浏览器访问：http://localhost:8888/getUser?username=spring 和 http://localhost:8888/getUser?username=testERROR Hystrix DashboardHystrix Dashboard仪表盘是根据系统一段时间内发生的请求情况来展示的可视化面板。Hystrix的指标需要端口进行支撑，所以需要增加actuator依赖。pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; HystrixDashboardApplication.java 12345678@SpringBootApplication@EnableDiscoveryClient@EnableHystrixDashboardpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; 上面是单个实例的Hystrix Dashboard,整个系统和集群的情况下并不是特别有用。Turbine就是聚合所有相关Hystrix.stream 流的方案。 网关治理组件 ZuulZuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. Zuul是对内部的微服务提供可配置的，对外URL到服务的映射关系，基于JVM的后端路由器。pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 启动类ZuulServerApplication.java 12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class ZuulServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulServerApplication.class, args); &#125;&#125; bootstrap.yml 12345678910111213141516spring: application: name: zuul-serverserver: port: 5555eureka: client: serviceUrl: defaultZone: http://$&#123;eureka.host:127.0.0.1&#125;:$&#123;eureka.port:8888&#125;/eureka/ instance: prefer-ip-address: truezuul: routes: client-a: path: /client/** serviceId: client-a 最后五行的代码表示，Zuul组件的端口为portA，则将/client开头的URL映射搭配client-a这个服务中去，即实际访问portB。/* 匹配任意数量的路径和字符/ 匹配任意数量的字符/? 匹配单个字符 Spring Cloud Zuul Filter链(1) Filter的类型(2) Filter的执行顺序(3) Filter的执行条件(4) Filter的执行效果Zuul有四种不同生命周期的Filter,分别是：pre Filter 按照规则路由到下级服务之前执行。比如鉴权、限流等route Filter 路由动作的执行者（Apache HttpClient或Netflix Ribbon构建和发送原始Http请求的地方）post Fliter 在源服务返回结果或者异常信息发生后执行的，对返回信息做一些处理error Filter 在整个生命周期内如果发生异常，则会进入error Filter Spring Cloud Zuul 权限集成OAuth2.0 + JWT(JSON Web Token) 动态路由 Dynamic Routing有两种解决方案：（1） Spring Cloud Config + Bus、动态刷新配置文件。（2） 重写Zuul的配置读取方式]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习]]></title>
    <url>%2F2018%2F12%2F11%2FSpringBoot%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. 1. 常见注解@RequestMapping (@GetMapping &amp; @PostMapping)The @RequestMapping annotation provides “routing” information. It tells Spring that any HTTP request with the / path should be mapped to the home method.@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。 @RestControllerThe @RestController annotation tells Spring to render the resulting string directly back to the caller.等价于 @Controller + @ResponseBody,为了使Http请求返回数据格式为json格式。 @EnableAutoConfigurationSince spring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly. @ConditionalOnProperty可以用来控制配置是否生效。 @SpringBootApplicationThe @SpringBootApplication annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items. same as @Configuration,@EnableAutoConfiguration,@ComponentScan. 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @ConfigurationDeclare the configuration Classes. @EnableAutoConfigurationIf you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them. 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; @EnableConfigurationProperties 和 @ConfigurationProperties这两个注解的作用可以参见 Spring Boot 官方文档 12345678910111213@Component@ConfigurationPropertiespublic class UriConfigurationProperties &#123; private String httpbin = "http://httpbin.org:80"; public String getHttpbin() &#123; return httpbin; &#125; public void setHttpbin(String httpbin) &#123; this.httpbin = httpbin; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package org.spring.cloud.gateway;import org.spring.cloud.gateway.properties.UriConfigurationProperties;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;@SpringBootApplication//@EnableConfigurationProperties(org.spring.cloud.gateway.properties.UriConfigurationProperties.class)public class GateWayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GateWayApplication.class, args); &#125; @Bean public RouteLocator myRoutes(RouteLocatorBuilder builder, UriConfigurationProperties uriConfiguration) &#123; String httpUri = uriConfiguration.getHttpbin(); return builder.routes() .route(p -&gt; p .path("/get") .filters(f -&gt; f.addRequestHeader("Hello", "World")) .uri(httpUri)) .route(p -&gt; p .host("*.hystrix.com") .filters(f -&gt; f .hystrix(config -&gt; config .setName("mycmd") .setFallbackUri("forward:/fallback"))) .uri(httpUri)) .build(); &#125;&#125; 上述两个文件位于两个包下，如果在第一个文件中使用了@Component，则在第二个文件中就不能再使用@EnableConfigurationProperties注解，否则将会报错，提示有两个Bean。如果第一个文件没有使用@Component则第二个文件可以将注释去掉。 单元测试常用注解 @RunWith(SpringJUnit4ClassRunner.class)引入Spring对JUnit4的支持。 @SpringApplicationConfiguration(classes = HelloApplication.class)指定SpringBoot的启动类 @WebAppConfiguration开启Web应用配置，用于模拟ServletContext @Before &amp; @Test &amp; @After@Before：JUnit中定义在测试用例@Test内容执行前预加载的内容，同理判断。 2. Starter POMs1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 命名规则都是spring-boot-starter-，代表一个特别的应用功能模块。 spring-boot-starter-web全栈Web开发模块，包含嵌入式的Tomcat、SpringMVC spring-boot-starter-test包含Junit、Hamcrest、Mockito spring-boot-starter-actuator为SpringBoot构建的应用提供一系列用于监控的端点。访问：http://127.0.0.1:8080/actuator可以看到输出了如下JSON文件： 123456789101112131415161718192021222324&#123; "_links": &#123; "self": &#123; "href": "http://127.0.0.1:8080/actuator", "templated": false &#125;, "health": &#123; "href": "http://127.0.0.1:8080/actuator/health", "templated": false &#125;, "health-component": &#123; "href": "http://127.0.0.1:8080/actuator/health/&#123;component&#125;", "templated": true &#125;, "health-component-instance": &#123; "href": "http://127.0.0.1:8080/actuator/health/&#123;component&#125;/&#123;instance&#125;", "templated": true &#125;, "info": &#123; "href": "http://127.0.0.1:8080/actuator/info", "templated": false &#125; &#125;&#125; spring-boot-devtools(1) Property Defaults(2) Automatic Restart(3) LiveReload(4) Global Settings(5) Remote Applications 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 配置文件SpringBoot的默认配置文件位置是src/main/resources/application.properties. 123&lt;!-- application.properties --&gt;book.name=JAVA编程思想book.author=Bruce Eckel 应用中可以使用 @Vlaue注解来加载这些自定义的参数 1234567@Componentpublic class Book &#123; @Value("$&#123;book.name&#125;") private String name; @value("$&#123;book.author&#125;") private String author;&#125; Java代码中引用有以下两种方式： PlaceHolder方式 ${…} SpEL表达式 #{…} 通过application-{profile}多环境配置文件：application-dev.properties:开发环境application-test.properties:测试环境application-prod.properties:生产环境在application.properties中的spring.profiles.active属性来设置。 12// 调用测试环境spring.profiles.active = test; 在采用java -jar xxx.jar 形式运行项目时，”–”就是对application.properties中的属性值进行赋值的标识。配置文件的优先级顺序如下：命令行输入 &gt; 包外 &gt; 包内所以可以在利用这一点来对配置进行快速准确的更改。 spring.factories文件Spring Factories实现原理(package org.springframework.core.io.support包下的SpringFactoriesLoader.class文件;)Spring 容器初始化时会加载该文件声明的类，我们可以通过@SpringBootApplspring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法： loadFactories: 根据接口类获取其实现类的实例，这个方法返回的是对象列表。loadFactoryNames: 根据接口获取其接口类的名称，这个方法返回的是类名的列表。 bootstrap.yml和appllication.yml的区别bootstrap.yml加载（父SpringApplicationContext）顺序在application.yml之前，用于应用程序上下文的引导阶段。用于指定spring.application.name和spring.cloud.config.server.git.uri以及一些加密和解密信息。eg：Spring Cloud Config 配置中心再使用时，通常将访问远程文件配置信息写在bootstrap.yml文件中。]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService学习]]></title>
    <url>%2F2018%2F11%2F26%2FWebService%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[WebService的两种实现方式，Soap WebService、Restful WebService。 RPC refers to Remote Procedure Call.Use of RPC is recommended when there is heavy use of the client/server model.RPC allows for the processing of multiple threads that share a given address.RPC employed on a platform that uses EJB.Web Service used in non-Java platforms when an app wants access.Web Service also is used for synchronization of asynchronous communication.[1] WebService是一种技术，有两种实现方式：JAX-WS(Java API for XML-Based Service面向消息)、JAX-RS(Java API for Restful WebService面向资源)ps. RESTful 请求常用的方法有以下四种： GET: 用于查询对象 POST: 用于创建对象 PUT: 用于修改对象 DELETE: 用于删除对象 1. CXF 基于 SOAP 的 WebService12345678&lt;!-- IHelloWorld.java --&gt;package top.leezy.www;import javax.jws.WebService;@WebServicepublic interface IHelloWorld &#123; String sayHello(String name);&#125; 12345678&lt;!-- HelloWorldImpl.java --&gt;package top.leezy.www;public class HelloWorldImpl implements IHelloWorld &#123; public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; 1234567891011121314151617&lt;!-- applicationContext.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jaxws="http://cxf.apache.org/jaxws" xmlns:cxf="http://cxf.apache.org/core" xmlns:wsa="http://cxf.apache.org/ws/addressing" xsi:schemaLocation="http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.1.xsd http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;jaxws:endpoint id="HelloWorld" implementor="top.leezy.www.HelloWorldImpl" address="/sayHello" /&gt; &lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- web.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;CXFwebservice&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:top/**/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;CxfServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CxfServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 打开浏览器输入：http://127.0.0.1:8081/SoapWebService/webservice 2. CXF 基于 RestFul 的 WebService12345678910111213141516&lt;!-- Config.java --&gt;package top.leezy.www;import java.util.LinkedList;import java.util.List;public class Config &#123; public static List&lt;User&gt; users; static &#123; users = new LinkedList&lt;User&gt;(); User user = new User(); user.setId("123456"); user.setName("SAKURA"); users.add(user); &#125;&#125; 12345678910111213141516171819202122232425262728&lt;!-- User.java --&gt;package top.leezy.www;import javax.xml.bind.annotation.XmlRootElement;@XmlRootElement(name = "User")public class User &#123; private String name; private String id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- UserService.java --&gt;package top.leezy.www;import javax.ws.rs.Consumes;import javax.ws.rs.DELETE;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.PUT;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.PathParam;import javax.ws.rs.QueryParam;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.Response.Status;@Path("/UserService")// 可以注释在方法上或者类上（以最小单位为准）, 指定返回给客户端的类型@Produces(&#123;"application/json", "application/xml"&#125;)public class UserService &#123; @GET @Path("/getUser/&#123;id&#125;") @Produces(MediaType.APPLICATION_XML) public User getUser(@PathParam("id") String id) &#123; if (id != null &amp;&amp; id.length() &gt; 0) &#123; for (User user : Config.users) &#123; if(id.equals(user.getId())) return user; &#125; User add_user = new User(); add_user.setId(id); return add_user; &#125; else &#123; return new User(); &#125; &#125; @POST @Path("/regUser") // 一般用于 @PUT、@POST, 用于接受客户端发送过来的MIME类型 @Consumes(&#123;"application/json", "application/xml"&#125;) public Response regUser(User user) &#123; if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125; else &#123; Config.users.add(user); return Response.ok("id = " + user.getId() + ", name = " + user.getName()).build(); &#125; &#125; @DELETE @Path("/delUser") @Consumes(&#123;"application/json", "application/xml"&#125;) public Response delPerson(@QueryParam("id") String id) &#123; User user = new User(); user.setId(id); if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125; else &#123; Config.users.remove(user); return Response.ok(user).build(); &#125; &#125; @PUT @Path("/updateUser") @Consumes(&#123;"application/json", "application/xml"&#125;) public Response updateUser(User user) &#123; if (Config.users.contains(user)) &#123; return Response.status(Status.BAD_REQUEST).build(); &#125;else &#123; for (User old_user : Config.users) &#123; if (old_user.equals(user)) &#123; old_user.setName(user.getName()); &#125; &#125; return Response.ok(user).build(); &#125; &#125;&#125; 123456789101112131415161718192021&lt;!-- beans.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jaxrs="http://cxf.apache.org/jaxrs" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd"&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml" /&gt; &lt;bean id="userService" class="top.leezy.www.UserService" /&gt; &lt;jaxrs:server id="rs_server" address="/restfulService"&gt; &lt;jaxrs:serviceBeans&gt; &lt;ref bean="userService" /&gt; &lt;/jaxrs:serviceBeans&gt; &lt;/jaxrs:server&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031&lt;!-- web.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CxfRestWebservice&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:top/**/beans.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 打开浏览器输入：http://127.0.0.1:8081/RestFulWebService/webservice/使用POSTMan进行测试：RestFul WebService 的JAR包较 Soap WebService 要区别以下几个：-javax.ws.rs-api-2.1.1.jar-cxf-rt-frontend-jaxrs-3.2.7.jar 参考文献：[1]http://www.differencebetween.net/technology/protocols-formats/difference-between-rpc-and-web-service/#ixzz5YLemRQhd[2]https://www.cnblogs.com/zhuyiqizhi/p/6213502.html]]></content>
      <tags>
        <tag>JavaWEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装Tomcat]]></title>
    <url>%2F2018%2F11%2F20%2FCentOS%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[系统：CentOS Linux release 7.5.1804Tomcat版本： apache-tomcat-7.0.92.tar.gz 1. 下载Tomcat下载链接：https://www-us.apache.org/dist/tomcat/tomcat-7/v7.0.92/bin/apache-tomcat-7.0.92.tar.gz 2. 解压缩文件1tar -zxvf apache-tomcat-7.0.92.tar.gz 3. 打开8080端口并重启防火墙12firewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --reload 4. 配置tomcat-users.xml12345&lt;!-- 在最后添加用户角色用户名密码 参数意义可以在自带的文档上查看--&gt;&lt;role rolename="admin-gui"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;role rolename="manager-jmx"/&gt;&lt;user username="admin" password="admin" roles="admin-gui,manager-gui,manager-jmx" /&gt; 5. 访问Tomcat Manager访问地址： http://192.168.56.101:8080/ 并登陆 admin admin]]></content>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB安装]]></title>
    <url>%2F2018%2F11%2F20%2FMongoDB%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装解压缩版本的MongoDB(mongodb-win32-x86_64-2008plus-ssl-4.0.4)的简单命令。 1. 配置环境变量12# 加入环境变量C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\bin 2. 创建 data 文件夹 及 log 文件夹创建 mongodb-data 和 mongodb-log 文件夹 3. 用管理员权限执行安装命令12cd C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\binmongod --dbpath "C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\mongodb-data" --logpath "C:\Program Files\mongodb-win32-x86_64-2008plus-ssl-4.0.4\mongodb-log\MongoDB.log" --install --serviceName "mongo" --logappend --directoryperdb 4. 测试安装结果访问 http://127.0.0.1:27017/]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实验记录]]></title>
    <url>%2F2018%2F03%2F06%2FTensorFlow%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[环境说明：系统：Ubuntu Server 16.04.1 LTS 64位Python版本：Python 3.5.2TensorFlow版本：1.4 用户切换（最好启用root否则会有Bug）1234# 输入Linux root用户密码sudo passwd root# 默认用户切换到root用户su root 安装python环境12345# 不用默认的2.7 安装python3.5sudo apt-get install python3.5# 系统环境切换成python3.5sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 安装TensorFlow12345678# 采用pip安装，首先安装# 查看系统内置的pip版本pip3 -V# 更新并安装sudo apt-get install python3-pip python3-devsudo pip install --upgrade pip# 安装CPU版本的TensorFlowpip3 install tensorflow 注意要保证pip是最新版本否则会出现以下错误： 测试TensorFlow123456python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello)) 查看TensorFlow版本 备用知识点(Note)123451. vim -r filename 恢复未正常保存生成的.swap文件2. (Note)convolutional neural network 卷积神经网络rectified linear unit 线性修正单元 ReLUinput layer --&gt; hidden layer(more than one) --&gt; output layer 环境准备12345678910111213pip3 install -U scikit-learnpip3 install scipy# 下载 MNIST 数据集（http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_download.html）wget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/t10k-images-idx3-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/t10k-labels-idx1-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/train-images-idx3-ubyte.gzwget http://tensorflow-1253902462.cosgz.myqcloud.com/mnist_cnn/train-labels-idx1-ubyte.gzpip3 install \ -i https://pypi.tuna.tsinghua.edu.cn/simple/ \ https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/tensorflow-1.7.0-cp35-cp35m-linux_x86_64.whl Windows环境下.ipynb文件相关（python笔记）1234567# 安装python环境不必多说pip install ipythonpip install &quot;ipython[notebook]&quot;# cd 到有.ipynb文件的目录下执行下列命令就会自动打开浏览器点击文件即可打开文件ipython notebook]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++标准模板库STL学习笔记]]></title>
    <url>%2F2018%2F02%2F27%2FC%2B%2B%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[面试笔试算法必备知识点！文章内容总结自《算法笔记》，时刻巩固以免忘记(lll￢ω￢) 1.vectory用法：Vectory：变长数组 定义方法： 1234567891011vectory&lt;typename&gt; name;// eg:vectory&lt;int&gt; nums;// 如果typename类型也是一个STL容器，定义方式如下：vectory&lt;vectory&lt;int&gt; &gt; name; // &gt;&gt;之间有空格避免歧义 --》两维都可变的二维数组// vectory数组的定义方式如下：vectory&lt;typename&gt; Arrayname[arraySize] // 一维可变的二维数组// eg:vectory&lt;int&gt; nums[10] 访问方法： 123456789// 通过下标访问：nums[0], nums[1];// 通过迭代器访问：vectory&lt;typename&gt;::iterator it;//eg:vectory&lt;int&gt;::iterator it; // 得到迭代器it，通过*it进行访问vectory// nums[i] 等价于 *(it + i) 常用函数： 1234567891. push_back(x) 在vectory末尾添加一个元素x O(1) nums.push_back(i);2. pop_back() 在vectory末尾删除一个元素 O(1) nums.pop_back();3. size() 求得vectory元素个数 O(1) nums.size()4. begin() 求得vectory数组nums首地址与it指向地址一样 O(1) nums.beagin()5. end() 求得vectory数组nums尾元素的下一个地址 O(1) nums.end()6. clear() 清空vectory所有元素 O(n) nums.clear()7. insert(it, x) 向vectory任意迭代器it处插入一个元素x O(N) nums.insert(nums.begin() + 2， 3)8. erase(it) 删除迭代器it处元素 O(n) nums.erase(nums.begin() + 2)9. erase(first, last) 删除[first, last)内的所有元素 O(n) nums.erase(num.begin() + 1, num.end())删除除第一个元素外的其他元素]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架总结]]></title>
    <url>%2F2017%2F08%2F09%2FSSM%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SSM框架的一些基本知识总结。 1.SSM定义SSM = Spring + SpringMVC + MyBatisSpring:Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC命名及分层：edu.xju.common.util 公共部分edu.xju.controller 控制层edu.xju.dao 数据层edu.xju.entity 实体层edu.xju.service 服务层 MyBatis:比Hibernate要灵活多用于需求不断变更的项目。 2.Web项目执行顺序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- web.xml 程序执行入口 --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- 如果使用如下配置，Spring Web MVC框架将加载“classpath:spring-mvc.xml”来进行初始化上下文而不是“/WEB-INF/[servlet名字]-servlet.xml”。 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 传给上下文实例（由contextClass指定）的字符串，用来指定上下文的位置。这个字符串可以被分成多个字符串（使用逗号作为分隔符） 来支持多个上下文（在多上下文的情况下，如果同一个bean被定义两次，后面一个优先）。 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- load-on-startup：表示启动容器时初始化该Servlet； --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;!-- url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;!-- 从main.jsp开始 --&gt; &lt;welcome-file&gt;main.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; DispatcherServlet拦截所有请求，在这里是拦截.do和.json结尾的请求。该DispatcherServlet默认使用WebApplicationContext作为上下文，Spring默认配置文件为“/WEB-INF/[servlet名字]-servlet.xml”。ContextLoaderListener初始化的上下文和DispatcherServlet初始化的上下文关系ContextLoaderListener初始化的上下文加载的Bean是对整个应用程序共享的；DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean；即只加载Web相关的组件。DispatcherServlet的继承关系 DispatcherServlet initialization parameters![DispatcherServlet initialization parameters](/assets/blogImg/DispatcherServlet initialization parameters.png) HttpServletBean继承HttpServlet，因此在Web容器启动时将调用它的init方法，该初始化方法的主要作用将Servlet初始化参数（init-param）设置到该组件上（如contextAttribute、contextClass、namespace、contextConfigLocation），通过BeanWrapper简化设值过程，方便后续使用；提供给子类初始化扩展点，initServletBean()，该方法由FrameworkServlet覆盖。 FrameworkServlet继承HttpServletBean，通过initServletBean()进行Web上下文初始化，该方法主要覆盖一下两件事情： 初始化web上下文； 提供给子类初始化扩展点； DispatcherServlet继承FrameworkServlet，并实现了onRefresh()方法提供一些前端控制器相关的配置； 12345678910111213141516171819202122232425262728&lt;!-- spring-mvc.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 扫描这个控制包内部的Controller --&gt; &lt;context:component-scan base-package="edu.xju.controller"/&gt; &lt;mvc:annotation-driven /&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// spring-mybatis.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;context:component-scan base-package="edu"/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb?charsetEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--sessionFactory代理--&gt; &lt;bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--注解扫描--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="edu.xju.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sessionFactory"/&gt; &lt;/bean&gt; &lt;!--spring 事务管理--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--定义事务声明 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceAop" expression="execution(* edu.xju.service.*Service.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceAop" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011121314151617181920212223// main.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;基本的 ssm 框架&lt;/title&gt;&lt;style type="text/css"&gt; a&#123; font-size: 20px; display: block; margin-top: 30px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/addUser.do"&gt;添加用户&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/list.do"&gt;查找所有用户&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/getUserA.json?id=1"&gt;获取某个用户JSON格式1&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/user/getUserB.json?id=2"&gt;获取某个用户JSON格式2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// UserController.javapackage edu.xju.controller;import java.util.List;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import edu.xju.common.util.JsonUtil;import edu.xju.entity.User;import edu.xju.service.UserService;@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; /** * 这个是返回页面 * @param model * @return */ @RequestMapping("/list.do") public String getUsers(Model model,HttpSession session)&#123; List&lt;User&gt; users = userService.getAll(); model.addAttribute("list",users); return "list"; &#125; /** * 获取json 的第一种方式 * 返回json 格式 * @param model * @param session * @param id * @return */ @RequestMapping("/getUserA.json") @ResponseBody public Object getUserByIdA(Model model,HttpSession session,Integer id )&#123; User user = userService.findUserById(id); return user; &#125; /** * 获取第json 的第二种方式 * @param model * @param response * @param session * @param id */ @RequestMapping("/getUserB.json") public void getUserByIdB(Model model,HttpServletResponse response,HttpSession session,Integer id )&#123; User user = userService.findUserById(id); JsonUtil.printByJSON(response, user); &#125; @RequestMapping("/addUser.do") public String insertUser(Model model,HttpSession session,Integer id,String name,Integer age )&#123; name = "测试姓名"; age = 99; User user = new User(name, age); userService.addUser(user); return "insertOK"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738// User.javapackage edu.xju.entity;public class User &#123; private Integer id; private String name; private int age; public User() &#123; &#125; public User( String name, int age) &#123; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 12345678910111213// UserService.javapackage edu.xju.service;import java.util.List;import edu.xju.entity.User;public interface UserService &#123; public List&lt;User&gt; getAll(); public User findUserById(Integer id); public void addUser(User user); &#125; 1234567891011121314151617181920212223242526272829// UserServiceImpl.javapackage edu.xju.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import edu.xju.dao.UserMapper;import edu.xju.entity.User;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; public List&lt;User&gt; getAll()&#123; return userMapper.getAll(); &#125; @Override public User findUserById(Integer id) &#123; return userMapper.getUserById(id); &#125; @Override public void addUser(User user) &#123; userMapper.insertUser(user); &#125;&#125; MyBatis 12345678910111213141516// UserMapper.javapackage edu.xju.dao;import java.util.List;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import edu.xju.entity.User;@Repositorypublic interface UserMapper &#123; public List&lt;User&gt; getAll(); public User getUserById(@Param("id")Integer id); public void insertUser(User user);&#125; 123456789101112131415161718192021// UserMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="edu.xju.dao.UserMapper" &gt; &lt;!-- 声明属性与查询字段之间的的对应关系 --&gt; &lt;resultMap id="BaseResultMap" type="edu.xju.entity.User" &gt; &lt;id column="id" property="id" jdbcType="INTEGER" /&gt; &lt;result column="name" property="name" jdbcType="VARCHAR" /&gt; &lt;result column="age" property="age" jdbcType="INTEGER" /&gt; &lt;/resultMap&gt; &lt;select id="getAll" resultMap="BaseResultMap"&gt; select id,name,age from user &lt;/select&gt; &lt;select id="getUserById" parameterType="int" resultMap="BaseResultMap"&gt; select id,name,age from user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="edu.xju.entity.User"&gt; insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3.序列图 4.常用注解解析： @Autowired 和 @Resource的使用场景和区别 @Autowired 是byType自动注入，是Spring的注解。@Resource默认是byName注入，默认使用成员属性的变量名注入，是Java自带的注解。 @Scope(“prototype”) 和 @Scope(“singleton”) 的区别 singleton 表示Spring容器中的单例，通过spring 容器获取该bean时总是返回唯一的实例。prototype 表示每次获取该bean时都会new 一个新的对象实例。 123456@Service@Scope("singleton")public class SingletonTestService &#123; private static int a = 0; private int b = 0;&#125; 如代码所示，如果设置为singleton，当a++和b++时，a和b都会增加。如果设置为prototype的话，则只有a会增加，b不会增加。 static 静态变量 静态变量整个内存中只有一个副本，为所有对象所共享，当且仅当类加载时才会被初始化；而非静态变量是对象所拥有的，在创建对象时被初始化，存在多个副本，每个对象之间拥有的副本互不影响。]]></content>
      <tags>
        <tag>JavaWEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计技巧]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[设计数据库的一些坑的总结。 1.Int与Integer的区别1234567891011121314151617181920/** * 学生 * 在使用Hibernate设计数据表声明数据类型时，Java代码中ID一般都设置成Integer类型，因为它可以默认为null，而 * 在使用性别时，一般都是使用Int类型 */@Entity@Table(name = "tb_student")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Student &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 年龄 private int age; // 性别 private int gender;&#125; 2.有依赖关联表与无依赖关联表一张表里只能有一个主键，或者有一种情况是one primary key included two fileds.有依赖关联表：通过在用户信息表里加入用户ID实现两张表的关联。 具体实现：逻辑模型物理模型 无依赖关联表：通过引入第三张表来进行用户表与用户信息表的关联。 3.Hibernate中一对一、一对多以及多对多的注解实现12345678910111213141516171819202122232425262728293031323334353637// 1:1 &lt;==&gt; Person:IdCard// Person.java@Entity@Table(name = "tb_person")public class Person &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 年龄 private int age; // 身份证 @OneToOne(mappedBy="person") //放弃维护主控权 private IdCard card;&#125;//IdCard.java@Entity@Table(name = "tb_idcard")public class IdCard &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 身份证号 private String sno; // 所属人 @OneToOne @JoinColumn(name="person_id", unique=true) private Person person;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 1:n &lt;==&gt; Department:Employee// Department.java@Entity@Table(name = "tb_dept")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Department &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 名称 @Column(length = 50) private String name; // 默认实体类所有字段都映射, 可使用@Transient声明不做映射 private int sn; // 拥有多个员工 @OneToMany(mappedBy = "dept") //mappedBy：表示放弃维护主控权 private Set&lt;Employee&gt; emps = new HashSet&lt;Employee&gt;();&#125;// Employee.java@Entity@Table(name="tb_emp")@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)public class Employee &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 部门 @ManyToOne @JoinColumn(name="dept_id") private Department dept;&#125; 123456789101112131415161718192021222324252627282930313233// n:n &lt;==&gt; Course:Student// Course.java@Entity@Table(name = "tb_course")public class Course &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; // 名称 private String name; // 学生 @ManyToMany @JoinTable(name="tb_student_course", joinColumns=@JoinColumn(name="course_id"), inverseJoinColumns=@JoinColumn(name="student_id")) private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();&#125;// Student.java@Entity@Table(name="tb_student")public class Student &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; // 姓名 private String name; // 课程 @ManyToMany(mappedBy="students") private Set&lt;Course&gt; courses = new HashSet&lt;Course&gt;();&#125;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试-Java基础知识]]></title>
    <url>%2F2017%2F07%2F28%2F%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[扎实基础！18.3.5日更新：碰壁并吸取经验教训！ 笔试让我明白了自己的一些问题。 123456byte a = 100;byte b = 10;byte c = a + b;// 报错 默认最低是Int类型byte c = (byte)a + b;int c = a + b; 1234567891011121314151617181920212223package com.lzy.test;public class Test1 &#123; public static void main(String[] args) &#123; int a = 0; int b = a++; System.out.println(a);//1 int c = ++a; System.out.println(a);//2 System.out.println(a++);//2 System.out.println(++a);//4 System.out.println(b);//0 System.out.println(c);//2 &#125;&#125;public static void main(String[] args) &#123; int a = 5; // a的变化：6 7 8 9 10 // b的变化： 5 7 7 8 10 int b = a++ + ++a + a++ + a++ + ++a; System.out.println(b); //37 &#125; 123456789101112131415161718public class Test2 &#123; public static void main(String[] args) &#123; int a = 0; //&amp;对每一个都判断； if (a==0 &amp; a++==1) &#123; System.out.println("&amp;");//不输出 &#125; System.out.println(a);//1 //&amp;&amp;只要前面是false就输出false，而不继续判断后面了 if (a==0 &amp;&amp; a++==1) &#123; System.out.println("&amp;&amp;");//不输出 &#125; if (a==1 &amp;&amp; a++==1) &#123; System.out.println("&amp;&amp;");//输出 &#125; &#125;&#125; 12345678910111213141516171819202122// 随机数 public static void main(String[] args) &#123; // 随机数产生的范围是[0, 1) double num = Math.random(); // 这样子[0, 0.5) [0.5, 1)才能真正平衡 if (num &gt;= 0.5) &#123; System.out.println("成都"); &#125; else &#123; System.out.println("赵雷"); &#125; // 输出指定范围的数字 // [26, 38] // 方法一： (int)(Math.random()*(max - min) + min); int a = 25; int b = 38; int scal = (int)(Math.random()*(b - a + 1)) + a; System.out.println(scal); // 方法二： int scall = (int)(Math.random() * 100 % 12) + a; System.out.println(scall); &#125; 基础知识点一：== 与 equal的区别： == 是一个运算符。 Equals则是string对象的方法，可以.（点）出来。 因为对象变量的存储的是对象在内存中的路径，即内存地址。所以用“==”比较时，即使对象的值相等，但是他们的内存地址不同(引用数据类型)，所以==的结果为false。故“==”用于比较两个变量的值是否相等，而不是变量引用的对象是否相等。 equal用于比较两个对象是否相同。 “==”比较的是值【变量(栈)内存中存放的对象的(堆)内存地址】equal用于比较两个对象的值是否相同【不是比地址】 【特别注意】Object类中的equals方法和“==”是一样的，没有区别，而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。”==”比”equal”运行速度快,因为”==”只是比较引用. 二：public、protected、private、default（friendly）的区别: public：可以被其他类访问private：只能被自己访问和修改protected:类内部、子类、同一个包中的类之间可以访问default：作用域是包，可以不写。被认为是friendly final关键字：修饰类：表示该类不能被继承，final类的所有成员方法都会被隐式的指定为final方法修饰方法：变是该方法不能被子类修改，类的private方法会被隐式的指定为final方法修饰变量：基本数据变量不可以被更改 引用类型变量不可以再更改指向另一个对象 Java线程安全与非线程安全：多线程安全优点体现在多个线程操作同一个对象，非线程安全 != 不安全线程安全是通过线程同步控制来实现的，也就是synchronized关键字。ArrayList是非线程安全 Vector是线程安全；HashMap是非线程安全 HashTable是线程安全；StringBuilder是非线程安全 StringBuffer是线程安全；http://blog.csdn.net/YiZhiCXY/article/details/51335385 String、StringBuffer、StringBuilder的区别：String： 字符串常量StringBuffer: 字符串变量（线程安全） 多线程下有优势StringBuilder: 字符串变量（非线程安全） 单线程下有优势 Array、ArrayList、Vectory、LinkedList的区别：(推荐看源码)ArrayList是为可变数组实现的，当更多的元素添加到ArrayList的时候，它的大小会动态增大。它的元素可以通过get/set方法直接访问，因为ArrayList本质上是一个数组。 1234567891011121314/** * Resizable-array implementation of the &#123;@code List&#125; interface. Implements * all optional list operations, and permits all elements, including * &#123;@code null&#125;. In addition to implementing the &#123;@code List&#125; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list. (This class is roughly equivalent to * &#123;@code Vector&#125;, except that it is unsynchronized.) * &lt;p&gt;The &#123;@code size&#125;, &#123;@code isEmpty&#125;, &#123;@code get&#125;, &#123;@code set&#125;, * &#123;@code iterator&#125;, and &#123;@code listIterator&#125; operations run in constant * time. The &#123;@code add&#125; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;, * that is, adding n elements requires O(n) time. All of the other operations * run in linear time (roughly speaking). The constant factor is low compared * to that for the &#123;@code LinkedList&#125; implementation. */ LinkedList是为双向链表实现的,非线程安全(not ) 123456789101112131415161718/** * Doubly-linked list implementation of the &#123;@code List&#125; and &#123;@code Deque&#125; * interfaces. Implements all optional list operations, and permits all * elements (including &#123;@code null&#125;). * * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked * list. Operations that index into the list will traverse the list from * the beginning or the end, whichever is closer to the specified index. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a linked list concurrently, and at least * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more elements; merely setting the value of * an element is not a structural modification.) This is typically * accomplished by synchronizing on some object that naturally * encapsulates the list. */ Vector与ArrayList相似，但是它是同步的。 12345678910111213141516/** * The &#123;@code Vector&#125; class implements a growable array of * objects. Like an array, it contains components that can be * accessed using an integer index. However, the size of a * &#123;@code Vector&#125; can grow or shrink as needed to accommodate * adding and removing items after the &#123;@code Vector&#125; has been created. * * &lt;p&gt;Each vector tries to optimize storage management by maintaining a * &#123;@code capacity&#125; and a &#123;@code capacityIncrement&#125;. The * &#123;@code capacity&#125; is always at least as large as the vector * size; it is usually larger because as components are added to the * vector, the vector's storage increases in chunks the size of * &#123;@code capacityIncrement&#125;. An application can increase the * capacity of a vector before inserting a large number of * components; this reduces the amount of incremental reallocation. */ 如果你的程序是线程安全的，ArrayList是一个比较好的选择。当更多的元素被添加的时候，Vector和ArrayList需要更多的空间。Vector每次扩容会增加一倍的空间，而ArrayList增加50%。 注意：ArrayList默认的初始空间大小相当的小，通过构造函数去初始化一个更大的空间是一个好习惯，可以避免扩容开销。部分引自于：https://www.cnblogs.com/chenpi/p/5505375.html Map、List、Set、Array的区别：https://www.cnblogs.com/chuanheliu/p/6363948.html Iterator 的hasNext方法和next方法:hasNext():如果仍有元素可以迭代，则返回 true。（换句话说，如果 next 返回了元素而不是抛出异常，则返回 true）。next():返回迭代的下一个元素。 12345678910111213141516/** * Returns &#123;@code true&#125; if the iteration has more elements. * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would * return an element rather than throwing an exception.) * * @return &#123;@code true&#125; if the iteration has more elements */boolean hasNext();/** * Returns the next element in the iteration. * * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */E next(); JAVA多线程和并发基础面试问答:http://www.cnblogs.com/dolphin0520/p/3932934.html Oracle数据库中TRUNCATE 与 DELETE 的区别： ROLLBACK可以撤销DELETE操作但撤销不了TRUNCATE操作 TRUNCATE TABLE比DELETE的速度快； TRUNCATE TABLE是删除表的所有行，而DELETE是删除表的一行或者多行 TRUNCATE TABLE在遇到任何一行违反约束(外键约束)时仍然删除表的所有行，但表的结构及其列、约束、索引等保持不变，DELETE则直接返回报错。 对于被外键约束的表，不能使用TRUNCATE TABLE，而应该使用不带WHERE语句的DELETE语句。 如果想保留标识计数值，要用DELETE，因为TRUNCATE TABLE会对新行标志符列搜用的计数值重置为该列的种子。 ###序列化的作用：为了保存在内存中的各种对象的状态（序列化），并且可以把保存的对象状态再读出来（反序列化）。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2017%2F07%2F27%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[今年7月中旬，我来到了成都，见识到了成都的美。 成都 让我掉下眼泪的 不止昨夜的酒 让我依依不舍的 不止你的温柔 余路还要走多久 你攥着我的手 让我感到为难的 是挣扎的自由 分别总是在九月 回忆是思念的愁 深秋嫩绿的垂柳 亲吻着我额头 在那座阴雨的小城里 我从未忘记你 成都 带不走的 只有你 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 分别总是在九月 回忆是思念的愁 深秋嫩绿的垂柳 亲吻着我额头 在那座阴雨的小城里 我从未忘记你 成都 带不走的 只有你 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
